fit_fpp3
# Built-in arima function
## Built-in fable AR(2)
y_ts <- tibble(time = 1:n, value = y) %>%
as_tsibble(index = time)
View(y_ts)
y_ts
fit_fpp3 <- y_ts %>%
model(ar2 = ARIMA(value ~ 0 + pdq(2,0,0)))
fit_fpp3
is.null(fit_fpp3)
is_null_model(fit_fpp3)
is_null_model(fit_fpp3)
# stats arima
fit = stats::arima(y, order=c(2,0,0), method="ML", include.mean = FALSE)
y_ts <- tibble(time = 1:n, value = y) %>%
as_tsibble(index = time)
fit_fpp3 <- y_ts %>%
model(ar2 = ARIMA(value ~ 0 + pdq(2,0,0)))
theta_hat_fpp3 <- c( coef(fit_fpp3)$estimate[1:2],as.numeric( glance(fit_fpp3)[,"sigma2"]))  # phi1, phi2
# Extract the model object (first row, column "ar2")
mod <- fit_fpp3$ar2[[1]]
# Test if it failed
fabletools::is_null_model(mod)
# boxplot for each parameters comparing each method
boxplot(mat_fl[,1], mat_cl[,1], mat_ls[,1], mat_fpp3[,1],mat_stats_arima[,1], names=c("Full lik","Cond lik","Least sq","fpp3", "stats"), main=expression(phi[1]), ylab=expression(hat(phi)[1]), outline = F)
# set n for simu
n = 4
B= 500
phi1 = .6
phi2 = .2
sigma=5
sigma2=sigma^2
# matrices to store results
mat_cl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_fl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_ls <- matrix(NA, nrow=B, ncol=3)
colnames(mat_ls) <- c("phi1","phi2","sigma2")
mat_fpp3 <- matrix(NA, nrow=B, ncol=3)
colnames(mat_fpp3) <- c("phi1","phi2","sigma2")
mat_stats_arima <- matrix(NA, nrow=B, ncol=3)
colnames(mat_stats_arima) <- c("phi1","phi2","sigma2")
for(b in seq(B)){
# b=103
# generate AR2
set.seed(123+b)
y = arima.sim(model = list(ar = c(phi1, phi2)), n = n, sd = sigma)
# full likelihood
fit_fl_optim <- optim(c(phi1, phi2 , log(sigma)), fn = full_loglik, y = y)
theta_hat_fl_optim <- c(phi1 = fit_fl_optim$par[1], phi2 = fit_fl_optim$par[2], sigma2 = exp(fit_fl_optim$par[3]))
mat_fl[b,] <- theta_hat_fl_optim
# Conditional likelihood with optim
fit_cl_optim <- optim(c(phi1, phi2 , log(sigma)), fn = cond_loglik, y = y)
theta_hat_cl_optim <- c(phi1 = fit_cl_optim$par[1], phi2 = fit_cl_optim$par[2], sigma2 = exp(fit_cl_optim$par[3]))
mat_cl[b,] <- theta_hat_cl_optim
# Least squares by hand
Y_ls <- y[3:n]
X_ls <- cbind(y[2:(n-1)], y[1:(n-2)])
phi_hat_ls <- solve(t(X_ls) %*% X_ls) %*% t(X_ls) %*% Y_ls
# residuals
res_ls <- Y_ls - X_ls %*% phi_hat_ls
# residual variance
sigma2_hat_ls <- sum(res_ls^2) / (n - 2)
# store
theta_hat_ls <- c(phi1 = phi_hat_ls[1], phi2 = phi_hat_ls[2], sigma2 = sigma2_hat_ls)
mat_ls[b,] <- theta_hat_ls
# Built-in arima function
## Built-in fable AR(2)
y_ts <- tibble(time = 1:n, value = y) %>%
as_tsibble(index = time)
fit_fpp3 <- y_ts %>%
model(ar2 = ARIMA(value ~ 0 + pdq(2,0,0)))
mod <- fit_fpp3$ar2[[1]]
if (!fabletools::is_null_model(mod)) {
theta_hat_fpp3 <- c(
coef(fit_fpp3)$estimate[1:2],
as.numeric(glance(fit_fpp3)[, "sigma2"])
)
mat_fpp3[b, ] <- theta_hat_fpp3
} else {
mat_fpp3[b, ] <- c(NA, NA, NA)  # fill NA if model failed
}
# stats arima
fit = stats::arima(y, order=c(2,0,0), method="ML", include.mean = FALSE)
theta_hat_stats_arima = c(fit$coef, fit$sigma2)
mat_stats_arima[b,] <- theta_hat_stats_arima
# save in matrix
cat(paste0(b, "\n"))
}
# set n for simu
n = 6
B= 500
phi1 = .6
phi2 = .2
sigma=5
sigma2=sigma^2
# matrices to store results
mat_cl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_fl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_ls <- matrix(NA, nrow=B, ncol=3)
colnames(mat_ls) <- c("phi1","phi2","sigma2")
mat_fpp3 <- matrix(NA, nrow=B, ncol=3)
colnames(mat_fpp3) <- c("phi1","phi2","sigma2")
mat_stats_arima <- matrix(NA, nrow=B, ncol=3)
colnames(mat_stats_arima) <- c("phi1","phi2","sigma2")
# set n for simu
n = 6
B= 100
phi1 = .6
phi2 = .2
sigma=5
sigma2=sigma^2
# matrices to store results
mat_cl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_fl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_ls <- matrix(NA, nrow=B, ncol=3)
colnames(mat_ls) <- c("phi1","phi2","sigma2")
mat_fpp3 <- matrix(NA, nrow=B, ncol=3)
colnames(mat_fpp3) <- c("phi1","phi2","sigma2")
mat_stats_arima <- matrix(NA, nrow=B, ncol=3)
colnames(mat_stats_arima) <- c("phi1","phi2","sigma2")
for(b in seq(B)){
# b=103
# generate AR2
set.seed(123+b)
y = arima.sim(model = list(ar = c(phi1, phi2)), n = n, sd = sigma)
# full likelihood
fit_fl_optim <- optim(c(phi1, phi2 , log(sigma)), fn = full_loglik, y = y)
theta_hat_fl_optim <- c(phi1 = fit_fl_optim$par[1], phi2 = fit_fl_optim$par[2], sigma2 = exp(fit_fl_optim$par[3]))
mat_fl[b,] <- theta_hat_fl_optim
# Conditional likelihood with optim
fit_cl_optim <- optim(c(phi1, phi2 , log(sigma)), fn = cond_loglik, y = y)
theta_hat_cl_optim <- c(phi1 = fit_cl_optim$par[1], phi2 = fit_cl_optim$par[2], sigma2 = exp(fit_cl_optim$par[3]))
mat_cl[b,] <- theta_hat_cl_optim
# Least squares by hand
Y_ls <- y[3:n]
X_ls <- cbind(y[2:(n-1)], y[1:(n-2)])
phi_hat_ls <- solve(t(X_ls) %*% X_ls) %*% t(X_ls) %*% Y_ls
# residuals
res_ls <- Y_ls - X_ls %*% phi_hat_ls
# residual variance
sigma2_hat_ls <- sum(res_ls^2) / (n - 2)
# store
theta_hat_ls <- c(phi1 = phi_hat_ls[1], phi2 = phi_hat_ls[2], sigma2 = sigma2_hat_ls)
mat_ls[b,] <- theta_hat_ls
# Built-in arima function
## Built-in fable AR(2)
y_ts <- tibble(time = 1:n, value = y) %>%
as_tsibble(index = time)
fit_fpp3 <- y_ts %>%
model(ar2 = ARIMA(value ~ 0 + pdq(2,0,0)))
mod <- fit_fpp3$ar2[[1]]
if (!fabletools::is_null_model(mod)) {
theta_hat_fpp3 <- c(
coef(fit_fpp3)$estimate[1:2],
as.numeric(glance(fit_fpp3)[, "sigma2"])
)
mat_fpp3[b, ] <- theta_hat_fpp3
} else {
mat_fpp3[b, ] <- c(NA, NA, NA)  # fill NA if model failed
}
# stats arima
fit = stats::arima(y, order=c(2,0,0), method="ML", include.mean = FALSE)
theta_hat_stats_arima = c(fit$coef, fit$sigma2)
mat_stats_arima[b,] <- theta_hat_stats_arima
# save in matrix
cat(paste0(b, "\n"))
}
# boxplot for each parameters comparing each method
boxplot(mat_fl[,1], mat_cl[,1], mat_ls[,1], mat_fpp3[,1],mat_stats_arima[,1], names=c("Full lik","Cond lik","Least sq","fpp3", "stats"), main=expression(phi[1]), ylab=expression(hat(phi)[1]), outline = F)
abline(h=phi1, col="red", lty=2)
boxplot(mat_fl[,2],mat_cl[,2], mat_ls[,2], mat_fpp3[,2],mat_stats_arima[,2],names = c("Full lik","Cond lik","Least sq","fpp3", "stats"), main=expression(phi[2]), ylab=expression(hat(phi)[2]))
# boxplot for each parameters comparing each method
boxplot(mat_fl[,1], mat_cl[,1], mat_ls[,1], mat_fpp3[,1],mat_stats_arima[,1], names=c("Full lik","Cond lik","Least sq","fpp3", "stats"), main=expression(phi[1]), ylab=expression(hat(phi)[1]), outline = F)
abline(h=phi1, col="red", lty=2)
boxplot(mat_fl[,2],mat_cl[,2], mat_ls[,2], mat_fpp3[,2],mat_stats_arima[,2],names = c("Full lik","Cond lik","Least sq","fpp3", "stats"), main=expression(phi[2]), ylab=expression(hat(phi)[2]), outline = F)
abline(h=phi2, col="red", lty=2)
boxplot(mat_fl[,3],mat_cl[,3], mat_ls[,3], mat_fpp3[,3],mat_stats_arima[,3],names= c("Full lik","Cond lik","Least sq","fpp3", "stats"), main=expression(sigma^2), ylab=expression(hat(sigma)^2), outline = F)
abline(h=sigma^2, col="red", lty=2)
# boxplot for each parameters comparing each method
boxplot(mat_fl[,1], mat_cl[,1], mat_ls[,1], mat_fpp3[,1],mat_stats_arima[,1], names=c("Full lik","Cond lik","Least sq","fpp3", "stats"), main=expression(phi[1]), ylab=expression(hat(phi)[1]), outline = F)
abline(h=phi1, col="red", lty=2)
# set n for simu
n = 8
B= 500
phi1 = .6
phi2 = .2
sigma=5
sigma2=sigma^2
# matrices to store results
mat_cl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_fl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_ls <- matrix(NA, nrow=B, ncol=3)
colnames(mat_ls) <- c("phi1","phi2","sigma2")
mat_fpp3 <- matrix(NA, nrow=B, ncol=3)
colnames(mat_fpp3) <- c("phi1","phi2","sigma2")
mat_stats_arima <- matrix(NA, nrow=B, ncol=3)
colnames(mat_stats_arima) <- c("phi1","phi2","sigma2")
for(b in seq(B)){
# b=103
# generate AR2
set.seed(123+b)
y = arima.sim(model = list(ar = c(phi1, phi2)), n = n, sd = sigma)
# full likelihood
fit_fl_optim <- optim(c(phi1, phi2 , log(sigma)), fn = full_loglik, y = y)
theta_hat_fl_optim <- c(phi1 = fit_fl_optim$par[1], phi2 = fit_fl_optim$par[2], sigma2 = exp(fit_fl_optim$par[3]))
mat_fl[b,] <- theta_hat_fl_optim
# Conditional likelihood with optim
fit_cl_optim <- optim(c(phi1, phi2 , log(sigma)), fn = cond_loglik, y = y)
theta_hat_cl_optim <- c(phi1 = fit_cl_optim$par[1], phi2 = fit_cl_optim$par[2], sigma2 = exp(fit_cl_optim$par[3]))
mat_cl[b,] <- theta_hat_cl_optim
# Least squares by hand
Y_ls <- y[3:n]
X_ls <- cbind(y[2:(n-1)], y[1:(n-2)])
phi_hat_ls <- solve(t(X_ls) %*% X_ls) %*% t(X_ls) %*% Y_ls
# residuals
res_ls <- Y_ls - X_ls %*% phi_hat_ls
# residual variance
sigma2_hat_ls <- sum(res_ls^2) / (n - 2)
# store
theta_hat_ls <- c(phi1 = phi_hat_ls[1], phi2 = phi_hat_ls[2], sigma2 = sigma2_hat_ls)
mat_ls[b,] <- theta_hat_ls
# Built-in arima function
## Built-in fable AR(2)
y_ts <- tibble(time = 1:n, value = y) %>%
as_tsibble(index = time)
fit_fpp3 <- y_ts %>%
model(ar2 = ARIMA(value ~ 0 + pdq(2,0,0)))
mod <- fit_fpp3$ar2[[1]]
if (!fabletools::is_null_model(mod)) {
theta_hat_fpp3 <- c(
coef(fit_fpp3)$estimate[1:2],
as.numeric(glance(fit_fpp3)[, "sigma2"])
)
mat_fpp3[b, ] <- theta_hat_fpp3
} else {
mat_fpp3[b, ] <- c(NA, NA, NA)  # fill NA if model failed
}
# stats arima
fit = stats::arima(y, order=c(2,0,0), method="ML", include.mean = FALSE)
theta_hat_stats_arima = c(fit$coef, fit$sigma2)
mat_stats_arima[b,] <- theta_hat_stats_arima
# save in matrix
cat(paste0(b, "\n"))
}
# set n for simu
n = 10
B= 500
phi1 = .6
phi2 = .2
sigma=5
sigma2=sigma^2
# matrices to store results
mat_cl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_fl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_ls <- matrix(NA, nrow=B, ncol=3)
colnames(mat_ls) <- c("phi1","phi2","sigma2")
mat_fpp3 <- matrix(NA, nrow=B, ncol=3)
colnames(mat_fpp3) <- c("phi1","phi2","sigma2")
mat_stats_arima <- matrix(NA, nrow=B, ncol=3)
colnames(mat_stats_arima) <- c("phi1","phi2","sigma2")
for(b in seq(B)){
# b=103
# generate AR2
set.seed(123+b)
y = arima.sim(model = list(ar = c(phi1, phi2)), n = n, sd = sigma)
# full likelihood
fit_fl_optim <- optim(c(phi1, phi2 , log(sigma)), fn = full_loglik, y = y)
theta_hat_fl_optim <- c(phi1 = fit_fl_optim$par[1], phi2 = fit_fl_optim$par[2], sigma2 = exp(fit_fl_optim$par[3]))
mat_fl[b,] <- theta_hat_fl_optim
# Conditional likelihood with optim
fit_cl_optim <- optim(c(phi1, phi2 , log(sigma)), fn = cond_loglik, y = y)
theta_hat_cl_optim <- c(phi1 = fit_cl_optim$par[1], phi2 = fit_cl_optim$par[2], sigma2 = exp(fit_cl_optim$par[3]))
mat_cl[b,] <- theta_hat_cl_optim
# Least squares by hand
Y_ls <- y[3:n]
X_ls <- cbind(y[2:(n-1)], y[1:(n-2)])
phi_hat_ls <- solve(t(X_ls) %*% X_ls) %*% t(X_ls) %*% Y_ls
# residuals
res_ls <- Y_ls - X_ls %*% phi_hat_ls
# residual variance
sigma2_hat_ls <- sum(res_ls^2) / (n - 2)
# store
theta_hat_ls <- c(phi1 = phi_hat_ls[1], phi2 = phi_hat_ls[2], sigma2 = sigma2_hat_ls)
mat_ls[b,] <- theta_hat_ls
# Built-in arima function
## Built-in fable AR(2)
y_ts <- tibble(time = 1:n, value = y) %>%
as_tsibble(index = time)
fit_fpp3 <- y_ts %>%
model(ar2 = ARIMA(value ~ 0 + pdq(2,0,0)))
mod <- fit_fpp3$ar2[[1]]
if (!fabletools::is_null_model(mod)) {
theta_hat_fpp3 <- c(
coef(fit_fpp3)$estimate[1:2],
as.numeric(glance(fit_fpp3)[, "sigma2"])
)
mat_fpp3[b, ] <- theta_hat_fpp3
} else {
mat_fpp3[b, ] <- c(NA, NA, NA)  # fill NA if model failed
}
# stats arima
fit = stats::arima(y, order=c(2,0,0), method="ML", include.mean = FALSE)
theta_hat_stats_arima = c(fit$coef, fit$sigma2)
mat_stats_arima[b,] <- theta_hat_stats_arima
# save in matrix
cat(paste0(b, "\n"))
}
# set n for simu
n = 15
B= 500
phi1 = .6
phi2 = .2
sigma=5
sigma2=sigma^2
# matrices to store results
mat_cl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_fl <- matrix(NA, nrow=B, ncol=3)
colnames(mat_cl) <- c("phi1","phi2","sigma2")
mat_ls <- matrix(NA, nrow=B, ncol=3)
colnames(mat_ls) <- c("phi1","phi2","sigma2")
mat_fpp3 <- matrix(NA, nrow=B, ncol=3)
colnames(mat_fpp3) <- c("phi1","phi2","sigma2")
mat_stats_arima <- matrix(NA, nrow=B, ncol=3)
colnames(mat_stats_arima) <- c("phi1","phi2","sigma2")
for(b in seq(B)){
# b=103
# generate AR2
set.seed(123+b)
y = arima.sim(model = list(ar = c(phi1, phi2)), n = n, sd = sigma)
# full likelihood
fit_fl_optim <- optim(c(phi1, phi2 , log(sigma)), fn = full_loglik, y = y)
theta_hat_fl_optim <- c(phi1 = fit_fl_optim$par[1], phi2 = fit_fl_optim$par[2], sigma2 = exp(fit_fl_optim$par[3]))
mat_fl[b,] <- theta_hat_fl_optim
# Conditional likelihood with optim
fit_cl_optim <- optim(c(phi1, phi2 , log(sigma)), fn = cond_loglik, y = y)
theta_hat_cl_optim <- c(phi1 = fit_cl_optim$par[1], phi2 = fit_cl_optim$par[2], sigma2 = exp(fit_cl_optim$par[3]))
mat_cl[b,] <- theta_hat_cl_optim
# Least squares by hand
Y_ls <- y[3:n]
X_ls <- cbind(y[2:(n-1)], y[1:(n-2)])
phi_hat_ls <- solve(t(X_ls) %*% X_ls) %*% t(X_ls) %*% Y_ls
# residuals
res_ls <- Y_ls - X_ls %*% phi_hat_ls
# residual variance
sigma2_hat_ls <- sum(res_ls^2) / (n - 2)
# store
theta_hat_ls <- c(phi1 = phi_hat_ls[1], phi2 = phi_hat_ls[2], sigma2 = sigma2_hat_ls)
mat_ls[b,] <- theta_hat_ls
# Built-in arima function
## Built-in fable AR(2)
y_ts <- tibble(time = 1:n, value = y) %>%
as_tsibble(index = time)
fit_fpp3 <- y_ts %>%
model(ar2 = ARIMA(value ~ 0 + pdq(2,0,0)))
mod <- fit_fpp3$ar2[[1]]
if (!fabletools::is_null_model(mod)) {
theta_hat_fpp3 <- c(
coef(fit_fpp3)$estimate[1:2],
as.numeric(glance(fit_fpp3)[, "sigma2"])
)
mat_fpp3[b, ] <- theta_hat_fpp3
} else {
mat_fpp3[b, ] <- c(NA, NA, NA)  # fill NA if model failed
}
# stats arima
fit = stats::arima(y, order=c(2,0,0), method="ML", include.mean = FALSE)
theta_hat_stats_arima = c(fit$coef, fit$sigma2)
mat_stats_arima[b,] <- theta_hat_stats_arima
# save in matrix
cat(paste0(b, "\n"))
}
# boxplot for each parameters comparing each method
boxplot(mat_fl[,1], mat_cl[,1], mat_ls[,1], mat_fpp3[,1],mat_stats_arima[,1], names=c("Full lik","Cond lik","Least sq","fpp3", "stats"), main=expression(phi[1]), ylab=expression(hat(phi)[1]), outline = F)
# boxplot for each parameters comparing each method
boxplot(mat_fl[,1], mat_cl[,1], mat_ls[,1], mat_fpp3[,1],mat_stats_arima[,1], names=c("Full lik","Cond lik","Least sq","fpp3", "stats"), main=expression(phi[1]), ylab=expression(hat(phi)[1]), outline = F)
abline(h=phi1, col="red", lty=2)
# clean ws
rm(list = ls())
#-------------------------------------------
# TP 1
#-------------------------------------------
# ---------------- ressources
# Forecasting book
## https://otexts.com/fpp3   3d edition
# Work on the following resources and understand how the tsibble function works and what are its
# arguments:
# tsibble objects presented in fpp3  https://otexts.com/fpp3/tsibbles.html
# documentation on tsibble objects   https://tsibble.tidyverts.org/
# tibble objects
## https://r4ds.had.co.nz/tibbles.html
# pipes
##  https://r4ds.hadley.nz/workflow-pipes.html
# ----------- example pipes
# set.seed(123)
# mean(tail(rnorm(10), 5))
# rnorm(10) %>%
#   tail(5) %>%
#   mean()
#
# iris
# iris
# library(dplyr)
# iris %>%  filter(Species == "setosa") %>%
#   filter(Sepal.Length >1.3) %>%
#   select(Sepal.Length, Species)
#
# ----------------------------- pkg
library(fpp3)
library(tsibble)
library(dplyr)
# -------------------------------------- exercise 1
# Load the built-in PBS dataset
data("PBS")
?PBS
# clean ws
rm(list = ls())
# ----------------------------- pkg
library(fpp3)
library(tsibble)
library(dplyr)
# Load the built-in PBS dataset
data("PBS")
?PBS
# Load the built-in PBS dataset
data("PBS")
?PBS
# Inspect the first rows
head(PBS)
# Check the time index
index(PBS)
# Check the key variables
key_vars(PBS)
# Find the first and last time points
range(PBS%>%pull(Month))
# Count number of observations per key (e.g., per ATC1)
PBS %>%
count(ATC1_desc)
# Create a tibble with monthly sales for two products
sales_data <- tibble(
month = rep(seq.Date(from = as.Date("2025-01-01"), by = "month", length.out = 6), 2),
product = rep(c("A", "B"), each = 6),
sales = c(10, 12, 15, 14, 18, 20, 8, 9, 12, 11, 13, 15)
)
# Convert the tibble into a tsibble
sales_tsibble <- sales_data %>%
as_tsibble(index = month, key = product)
# Inspect the tsibble
sales_tsibble
str(sales_tsibble)
# Plot sales over time for each product
ggplot(sales_tsibble, aes(x = month, y = sales, color = product)) +
geom_line() +
geom_point() +
labs(title = "Monthly Sales for Products A and B",
x = "Month", y = "Sales")
# Read the CSV file
sales_data <- read_csv("TP/data/smartphone_sales.csv")
# Convert to tsibble
sales_tsibble <- sales_data %>%
as_tsibble(index = month, key = model)
# Inspect the tsibble
sales_tsibble
head(sales_tsibble)
# Optional: Plot monthly sales for each smartphone model
ggplot(sales_tsibble, aes(x = month, y = units_sold, color = model)) +
geom_line() +
geom_point() +
labs(title = "Monthly Smartphone Sales",
x = "Month", y = "Units Sold")
library(tsibbledata)
gafa_stock
str(gafa_stock)
?gafa_stock
vic_elec
data(vic_elec)
?vis_elec
help(PBS)
data(PBS)
PBS
View(PBS)
PBS |> filter(ATC2 == "A10", ATC1 == "A")  |>
summarise(Total = sum(Cost)) -> A10
autoplot(A10)
# group_by not needed in tsibble for the index
interval(PBS)
help(vic_elec)
?pelt
?USgas
# 3. The USgas package contains data on the demand for natural gas in the US.
# (a) Install the USgas package.
# install.packages("USgas")
library(USgas)
help(USgas)
# 3. The USgas package contains data on the demand for natural gas in the US.
# (a) Install the USgas package.
# install.packages("USgas")
library(USgas)
help(USgas)
?us_total
?aus_production
