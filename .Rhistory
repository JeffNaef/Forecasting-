dat[runif(5000) > 0.5, 2] <- NA
dat_imp_norm <- mice::mice(dat, m = 1, method = "norm")
dat_imp_norm <- mice::complete(dat_imp_norm) %>%
mutate(missing = is.na(dat[, 2]))
dat_imp_norm.predict <- mice::mice(dat, m = 1, method = "norm.predict")
dat_imp_norm.predict <- mice::complete(dat_imp_norm.predict) %>%
mutate(missing = is.na(dat[, 2]))
dat_full <- dat_full %>%
as.data.frame() %>%
mutate(missing = is.na(dat[, 2]))
###################################
coef(lm(X1 ~ X2, data = dat_imp_norm.predict))
coef(lm(X2 ~ X1, data = dat_imp_norm.predict))
coef(lm(X1 ~ X2, data = dat_imp_norm))
coef(lm(X2 ~ X1, data = dat_imp_norm))
coef(lm(X1 ~ X2, data = dat_full))
coef(lm(X2 ~ X1, data = dat_full))
#############################
p1 <- ggplot(dat_imp_norm.predict, aes(x = X1, y = X2, col = missing)) +
geom_point() +
geom_point(aes(x = 30, y = 30, color = "new_category"), size = 5, show.legend = TRUE) +
scale_color_manual(name = "",
values = c("FALSE" = "#0D3B66",
"TRUE" = "#FB3640",
"new_category" = "springgreen3"),
labels = c("FALSE" = "observed",
"TRUE" = "imputed",
"new_category" = "true (missing)"),
breaks = c("FALSE", "TRUE", "new_category")) +
theme_minimal(base_size = 16) +
ggtitle("Missing data imputed by\nRegression Imputation") +
xlim(min(dat_imp_norm.predict$X1), max(dat_imp_norm.predict$X1)) +
ylim(min(dat_imp_norm.predict$X2), max(dat_imp_norm.predict$X2)) +
theme(axis.title.y = element_blank(),
axis.text.y = element_blank())
p2 <- ggplot(dat_imp_norm, aes(x = X1, y = X2, col = missing)) +
geom_point() +
theme_minimal(base_size = 16) +
ggtitle("Missing data imputed by\nGaussian Imputation") +
geom_point(aes(x = 30, y = 30, color = "new_category"), size = 5, show.legend = TRUE) +
scale_color_manual(name = "",
values = c("FALSE" = "#0D3B66",
"TRUE" = "#FB3640",
"new_category" = "springgreen3"),
labels = c("FALSE" = "observed",
"TRUE" = "imputed",
"new_category" = "true (missing)"),
breaks = c("FALSE", "TRUE", "new_category")) +
xlim(min(dat_imp_norm$X1), max(dat_imp_norm$X1)) +
ylim(min(dat_imp_norm$X2), max(dat_imp_norm$X2)) +
theme(axis.title.y = element_blank(),
axis.text.y = element_blank())
p3 <- ggplot(dat_full, aes(x = X1, y = X2, col = missing)) +
geom_point() +
scale_color_manual(values = c("#0D3B66", "springgreen3"),
name = "", labels = c("observed", "missing")) +
theme_minimal(base_size = 16) +
ggtitle("True data") +
theme(legend.position = "none")
((p3 + p1 + p2 + plot_layout(guides = "collect")) &
guides(color = guide_legend(override.aes = list(size = 5)))) +
plot_annotation(tag_levels = 'A') &
theme(plot.tag = element_text(size = 20, face = "bold"))
setwd("C:/Users/Jeff/OneDrive/Dokumente/Studium/PhD/Projects with Marc/Github/Forecasting-")
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(CLVTools)
load("Gift-v1.Rdata")
clv.gift <- clvdata(mydata,
date.format="ymd",
time.unit = "week",
estimation.split = 156, #156,
name.id = "Id",
name.date = "Date",
name.price = "Price")
plot(clv.gift)
# Remove all other covariates
covariates.dynamic<-covariates.dynamic[,c("Id", "Cov.Date")]
# (1) Holiday dummy for December and surrounding months
# Define which months should be considered as "holiday period"
covariates.dynamic[, holiday := ifelse(month(Cov.Date) %in% c(11, 12, 1), 1, 0)]
# Alternative: only December
# dt[, holiday := ifelse(month(Cov.Date) == 12, 1, 0)]
# (2) Fourier terms for dynamic regression
# Set K (number of Fourier pairs)
K <- 3  # You can adjust this
# Create time index t (starts at 0)
covariates.dynamic[, t := 0:(.N-1), by = Id]
# Generate Fourier terms for each k from 1 to K
for(k in 1:K) {
# Sine term
covariates.dynamic[, paste0("sin_", k) := sin(2 * pi * k * t / 52)]
# Cosine term
covariates.dynamic[, paste0("cos_", k) := cos(2 * pi * k * t / 52)]
}
# Check the result
head(covariates.dynamic, 20)
nam<-colnames(covariates.dynamic)[3:ncol(covariates.dynamic)]
clv.dynamic <- SetDynamicCovariates(
clv.data = clv.gift,
data.cov.life = covariates.dynamic,
data.cov.trans = covariates.dynamic,
names.cov.life =nam,
names.cov.trans = nam,
name.id = "Id",
name.date = "Cov.Date"
)
est.pnbd.K0 <- latentAttrition(
formula =~ holiday|holiday ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "BFGS"))
est.pnbd.K1 <- latentAttrition(
formula =~ holiday|holiday+sin_1+cos_1 ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "BFGS"))
est.pnbd.K1 <- latentAttrition(
formula =~ holiday|holiday+sin_1+cos_1 ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "BFGS"))
est.pnbd.K2 <- latentAttrition(
formula =~ holiday|holiday+sin_1+cos_1 + sin_2 + cos_2 ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "BFGS"))
est.pnbd.K3 <- latentAttrition(
formula =~ holiday|holiday+sin_1+cos_1 + sin_2 + cos_2 + sin_3 + cos_3 ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "Nelder-Mead"))
summary(est.pnbd.K3)
plot(est.pnbd.K3)
plot(est.pnbd.K2)
# (2) Fourier terms for dynamic regression
# Set K (number of Fourier pairs)
K <- 4  # You can adjust this
# Create time index t (starts at 0)
covariates.dynamic[, t := 0:(.N-1), by = Id]
# Generate Fourier terms for each k from 1 to K
for(k in 1:K) {
# Sine term
covariates.dynamic[, paste0("sin_", k) := sin(2 * pi * k * t / 52)]
# Cosine term
covariates.dynamic[, paste0("cos_", k) := cos(2 * pi * k * t / 52)]
}
est.pnbd.K4 <- latentAttrition(
formula =~ holiday|holiday+sin_1+cos_1 + sin_2 + cos_2 + sin_3 + cos_3 + sin_4 + cos_4 ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "Nelder-Mead"))
nam<-colnames(covariates.dynamic)[3:ncol(covariates.dynamic)]
clv.dynamic <- SetDynamicCovariates(
clv.data = clv.gift,
data.cov.life = covariates.dynamic,
data.cov.trans = covariates.dynamic,
names.cov.life =nam,
names.cov.trans = nam,
name.id = "Id",
name.date = "Cov.Date"
)
est.pnbd.K4 <- latentAttrition(
formula =~ holiday|holiday+sin_1+cos_1 + sin_2 + cos_2 + sin_3 + cos_3 + sin_4 + cos_4 ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "Nelder-Mead"))
plot(est.pnbd.K4)
summary(est.pnbd.K4)
est.pnbd.K4@prediction.params.model
est.pnbd.K4@LL.data
summary(est.pnbd.K4)
tmp<-summary(est.pnbd.K4)
tmp$AIC
summary(est.pnbd.K4)$AIC
AIC_K0<-summary(est.pnbd.K0)$AIC
AIC_K1<-summary(est.pnbd.K1)$AIC
AIC_K2<-summary(est.pnbd.K2)$AIC
AIC_K3<-summary(est.pnbd.K3)$AIC
AIC_K4<-summary(est.pnbd.K4)$AIC
(AIC_K0<-summary(est.pnbd.K0)$AIC)
# Create a named list to store AIC values
aic_values <- setNames(
numeric(5),
paste0("K", 0:4)
)
# Get list of model objects
models <- list(
K0 = est.pnbd.K0,
K1 = est.pnbd.K1,
K2 = est.pnbd.K2,
K3 = est.pnbd.K3,
K4 = est.pnbd.K4
)
# Loop through models and extract AIC
for (i in seq_along(models)) {
aic_values[i] <- summary(models[[i]])$AIC
}
# Create results data frame
aic_results <- data.frame(
Model = names(aic_values),
AIC = aic_values,
Delta_AIC = aic_values - min(aic_values),
row.names = NULL
)
# Sort by AIC
aic_results <- aic_results[order(aic_results$AIC), ]
# Display results
print(aic_results, row.names = FALSE)
# Highlight the best model
cat("\n")
cat("Best model:", aic_results$Model[1],
"with AIC =", round(aic_results$AIC[1], 2), "\n")
models
aic_results$Model[1]
models[aic_results$Model[1]]
plot(models[aic_results$Model[1]])
models[aic_results$Model[1]]
models
models[aic_results$Model[1]][[1]]
plot(models[aic_results$Model[1]][[1]])
##Predict the GG model separately
est.gg <- spending(family = gg, data = clv.gift)
h<-104
# select a given horizon to analyse forecasting for different segment for H = 52,104,156, 208
dt.pred.cov <- predict(models[aic_results$Model[1]][[1]], predict.spending = est.gg,prediction.end=h)
dt.pred.cov
rmse <- function(x, y){sqrt(mean((x - y)^2))}
rmse(dt.pred.cov$actual.period.spending, dt.pred.cov$predicted.period.spending)
?pnbd
mydata
# RMSE using the standard model ignoring covariates:
clv.standard <- clvdata( mydata, date.format = "ymd", time.unit = "week",  estimation.split = 156,
name.id = "Id", name.date = "Date", name.price = "Price")
clv.static <- pnbd(clv.standard)
# select a given horizon to analyse forecasting for different segment for H = 52,104,156, 208
dt.pred.cov <- predict(clv.static, predict.spending = est.gg,prediction.end=h)
clv.static <- pnbd(clv.standard)
# select a given horizon to analyse forecasting for different segment for H = 52,104,156, 208
dt.pred.static <- predict(clv.static, predict.spending = est.gg,prediction.end=h)
#RMSE using the best model
rmse(dt.pred.static$actual.period.spending, dt.pred.static$predicted.period.spending)
# select a given horizon to analyse forecasting for different segment for H = 52,104,156, 208
dt.pred.cov <- predict(models[aic_results$Model[1]][[1]], predict.spending = est.gg,prediction.end=h)
#RMSE using the best model
rmse(dt.pred.cov$actual.period.spending, dt.pred.cov$predicted.period.spending)
# RMSE using the standard model ignoring covariates:
clv.standard <- clvdata( mydata, date.format = "ymd", time.unit = "week",  estimation.split = 156,
name.id = "Id", name.date = "Date", name.price = "Price")
clv.static <- pnbd(clv.standard)
# select a given horizon to analyse forecasting for different segment for H = 52,104,156, 208
dt.pred.static <- predict(clv.static, predict.spending = est.gg,prediction.end=h)
#RMSE using the best model
rmse(dt.pred.static$actual.period.spending, dt.pred.static$predicted.period.spending)
clv.dynamic
clv.gift <- clvdata(mydata,
date.format="ymd",
time.unit = "week",
estimation.split = 156, #156,
name.id = "Id",
name.date = "Date",
name.price = "Price")
plot(clv.gift)
nam<-colnames(covariates.dynamic)[3:ncol(covariates.dynamic)]
clv.dynamic <- SetDynamicCovariates(
clv.data = clv.gift,
data.cov.life = covariates.dynamic,
data.cov.trans = covariates.dynamic,
names.cov.life =nam,
names.cov.trans = nam,
name.id = "Id",
name.date = "Cov.Date"
)
head(covariates.dynamic)
load("Gift-v1.Rdata")
clv.gift <- clvdata(mydata,
date.format="ymd",
time.unit = "week",
estimation.split = 156, #156,
name.id = "Id",
name.date = "Date",
name.price = "Price")
plot(clv.gift)
covariates.dynamic[, holiday := ifelse(month(Cov.Date) %in% c(11, 12, 1), 1, 0)]
nam<-colnames(covariates.dynamic)[3:ncol(covariates.dynamic)]
clv.dynamic <- SetDynamicCovariates(
clv.data = clv.gift,
data.cov.life = covariates.dynamic,
data.cov.trans = covariates.dynamic,
names.cov.life =nam,
names.cov.trans = nam,
name.id = "Id",
name.date = "Cov.Date"
)
head(covariates.dynamic)
covariates.dynamic[, grep("^biweek_", names(covariates.dynamic)), with = FALSE]
headcovariates.dynamic
head(covariates.dynamic)
covariates.dynamic<-covariates.dynamic[, c("Id", "Cov.Date", "holiday" grep("^biweek_", names(covariates.dynamic)) ), with = FALSE]
covar c("Id", "Cov.Date", "holiday" grep("^biweek_", names(covariates.dynamic)) )
covar c("Id", "Cov.Date", "holiday" grep("^biweek_", names(covariates.dynamic)) ) c("Id", "Cov.Date", "holiday" grep("^biweek_", names(covariates.dynamic)) )
c("Id", "Cov.Date", "holiday" grep("^biweek_", names(covariates.dynamic)) )
covariates.dynamic<-covariates.dynamic[, c("Id", "Cov.Date", "holiday", grep("^biweek_", names(covariates.dynamic)) ), with = FALSE]
c("Id", "Cov.Date", "holiday", grep("^biweek_", names(covariates.dynamic)) )
covariates.dynamic[, c("Id", "Cov.Date", "holiday" ), with = FALSE]
covariates.dynamic[, c("Id", "Cov.Date", "holiday" )&grep("^biweek_", names(covariates.dynamic)), with = FALSE]
biweek_cols <- covariates.dynamic[, c("Id", "Cov.Date", grep("^biweek_", names(covariates.dynamic), value = TRUE)), with = FALSE]
covariates.dynamic<-covariates.dynamic[, c("Id", "Cov.Date", grep("^biweek_", names(covariates.dynamic), value = TRUE)), with = FALSE]
covariates.dynamic
load("Gift-v1.Rdata")
clv.gift <- clvdata(mydata,
date.format="ymd",
time.unit = "week",
estimation.split = 156, #156,
name.id = "Id",
name.date = "Date",
name.price = "Price")
plot(clv.gift)
covariates.dynamic[, holiday := ifelse(month(Cov.Date) %in% c(11, 12, 1), 1, 0)]
nam<-colnames(covariates.dynamic)[3:ncol(covariates.dynamic)]
covariates.dynamic<-covariates.dynamic[, c("Id", "Cov.Date", "holiday", grep("^biweek_", names(covariates.dynamic), value = TRUE)), with = FALSE]
head(covariates.dynamic)
clv.dynamic <- SetDynamicCovariates(
clv.data = clv.gift,
data.cov.life = covariates.dynamic,
data.cov.trans = covariates.dynamic,
names.cov.life =nam,
names.cov.trans = nam,
name.id = "Id",
name.date = "Cov.Date"
)
nam<-colnames(covariates.dynamic)[3:ncol(covariates.dynamic)]
clv.dynamic <- SetDynamicCovariates(
clv.data = clv.gift,
data.cov.life = covariates.dynamic,
data.cov.trans = covariates.dynamic,
names.cov.life =nam,
names.cov.trans = nam,
name.id = "Id",
name.date = "Cov.Date"
)
est.pnbd.full <- latentAttrition(
formula =~ holiday|.,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "Nelder-Mead"))
##Predict the GG model separately
est.gg <- spending(family = gg, data = clv.gift)
h<-104
# select a given horizon to analyse forecasting for different segment for H = 52,104,156, 208
dt.pred.cov <- predict(est.pnbd.full, predict.spending = est.gg,prediction.end=h)
#RMSE using the best model
rmse(dt.pred.cov$actual.period.spending, dt.pred.cov$predicted.period.spending)
#RMSE using the best model
rmse(dt.pred.cov$actual.period.spending, dt.pred.cov$predicted.period.spending)
rmse <- function(x, y){sqrt(mean((x - y)^2))}
#RMSE using the best model
rmse(dt.pred.cov$actual.period.spending, dt.pred.cov$predicted.period.spending)
plot(est.pnbd.full)
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(CLVTools)
load("Gift-v1.Rdata")
clv.gift <- clvdata(mydata,
date.format="ymd",
time.unit = "week",
estimation.split = 156, #156,
name.id = "Id",
name.date = "Date",
name.price = "Price")
plot(clv.gift)
# Remove all other covariates
covariates.dynamic<-covariates.dynamic[,c("Id", "Cov.Date")]
# (1) Holiday dummy for December and surrounding months
# Define which months should be considered as "holiday period"
covariates.dynamic[, holiday := ifelse(month(Cov.Date) %in% c(11, 12, 1), 1, 0)]
# Alternative: only December
# dt[, holiday := ifelse(month(Cov.Date) == 12, 1, 0)]
# (2) Fourier terms for dynamic regression
# Set K (number of Fourier pairs)
K <- 5  # You can adjust this
# Create time index t (starts at 0)
covariates.dynamic[, t := 0:(.N-1), by = Id]
# Generate Fourier terms for each k from 1 to K
for(k in 1:K) {
# Sine term
covariates.dynamic[, paste0("sin_", k) := sin(2 * pi * k * t / 52)]
# Cosine term
covariates.dynamic[, paste0("cos_", k) := cos(2 * pi * k * t / 52)]
}
# Check the result
head(covariates.dynamic, 20)
nam<-colnames(covariates.dynamic)[3:ncol(covariates.dynamic)]
clv.dynamic <- SetDynamicCovariates(
clv.data = clv.gift,
data.cov.life = covariates.dynamic,
data.cov.trans = covariates.dynamic,
names.cov.life =nam,
names.cov.trans = nam,
name.id = "Id",
name.date = "Cov.Date"
)
# est.pnbd.static.full <- latentAttrition(
#   formula =~.|. ,
#   family = pnbd,
#   data = clv.dynamic,
#   optimx.args = list(method = "Nelder-Mead"))
est.pnbd.K0 <- latentAttrition(
formula =~ holiday|holiday ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "BFGS"))
est.pnbd.K1 <- latentAttrition(
formula =~ holiday|holiday+sin_1+cos_1 ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "BFGS"))
est.pnbd.K2 <- latentAttrition(
formula =~ holiday|holiday+sin_1+cos_1 + sin_2 + cos_2 ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "BFGS"))
est.pnbd.K3 <- latentAttrition(
formula =~ holiday|holiday+sin_1+cos_1 + sin_2 + cos_2 + sin_3 + cos_3 ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "Nelder-Mead"))
est.pnbd.K4 <- latentAttrition(
formula =~ holiday|holiday+sin_1+cos_1 + sin_2 + cos_2 + sin_3 + cos_3 + sin_4 + cos_4 ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "Nelder-Mead"))
est.pnbd.K5 <- latentAttrition(
formula =~ holiday|holiday+sin_1+cos_1 + sin_2 + cos_2 + sin_3 + cos_3 + sin_4 + cos_4 + sin_5 + cos_5 ,
family = pnbd,
data = clv.dynamic,
optimx.args = list(method = "Nelder-Mead"))
# Create a named list to store AIC values
aic_values <- setNames(
numeric(5),
paste0("K", 0:5)
)
K
# Create a named list to store AIC values
aic_values <- setNames(
numeric(K+1),
paste0("K", 0:5)
)
# Get list of model objects
models <- list(
K0 = est.pnbd.K0,
K1 = est.pnbd.K1,
K2 = est.pnbd.K2,
K3 = est.pnbd.K3,
K4 = est.pnbd.K4,
K4 = est.pnbd.K5
)
# Loop through models and extract AIC
for (i in seq_along(models)) {
aic_values[i] <- summary(models[[i]])$AIC
}
# Create results data frame
aic_results <- data.frame(
Model = names(aic_values),
AIC = aic_values,
Delta_AIC = aic_values - min(aic_values),
row.names = NULL
)
# Sort by AIC
aic_results <- aic_results[order(aic_results$AIC), ]
# Display results
print(aic_results, row.names = FALSE)
# Highlight the best model
cat("\n")
cat("Best model:", aic_results$Model[1],
"with AIC =", round(aic_results$AIC[1], 2), "\n")
rmse <- function(x, y){sqrt(mean((x - y)^2))}
plot(models[aic_results$Model[1]][[1]])
aic_results
aic_results$Model[1]]
models
# Get list of model objects
models <- list(
K0 = est.pnbd.K0,
K1 = est.pnbd.K1,
K2 = est.pnbd.K2,
K3 = est.pnbd.K3,
K4 = est.pnbd.K4,
K5 = est.pnbd.K5
)
# Loop through models and extract AIC
for (i in seq_along(models)) {
aic_values[i] <- summary(models[[i]])$AIC
}
# Sort by AIC
aic_results <- aic_results[order(aic_results$AIC), ]
# Display results
print(aic_results, row.names = FALSE)
# Highlight the best model
cat("\n")
cat("Best model:", aic_results$Model[1],
"with AIC =", round(aic_results$AIC[1], 2), "\n")
rmse <- function(x, y){sqrt(mean((x - y)^2))}
plot(models[aic_results$Model[1]][[1]])
plot(models[aic_results$Model[1]][[1]])
##Predict the GG model separately
est.gg <- spending(family = gg, data = clv.gift)
h<-104
# select a given horizon to analyse forecasting for different segment for H = 52,104,156, 208
dt.pred.cov <- predict(models[aic_results$Model[1]][[1]], predict.spending = est.gg,prediction.end=h)
#RMSE using the best model
rmse(dt.pred.cov$actual.period.spending, dt.pred.cov$predicted.period.spending)
