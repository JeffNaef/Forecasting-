)
# have a look at the parameters
report(holt_fit_MAN)
# MMN model
holt_fit_MMN <- lux_export |>
model(
`Holt's method` = ETS(Exports ~ error("M") + trend("M") + season("N"))
)
# have a look at the parameters
report(holt_fit_MMN)
par(mfrow=c(2,2))
for(i in seq(0.5, 0.9, 0.2)){
for(j in seq(0.1, 0.5, 0.2)){
holt_par <- forecast::holt(lux_export$Exports, alpha = i, beta = j,
initial = "optimal", h = 1)
alpha_beta_txt = paste("Holt's alpha and beta:", i, j, sep=" ")
rmse = round(sqrt(sum(holt_par$residuals^2)/length(holt_par$residuals)),2)
rmse_txt = paste("rmse:", rmse, sep=" ")
title_txt = paste(alpha_beta_txt, rmse_txt, sep =" ")
plot(holt_par, main = title_txt, PI=FALSE)
lines(fitted(holt_par), lwd=2, col="red")
}
}
par(mfrow=c(1,1))
# MMN model
holt_fit_MMN <- lux_export |>
model(
`Holt's method` = ETS(Exports ~ error("M") + trend("M") + season("N"))
)
# have a look at the parameters
report(holt_fit_MMN)
# components
components(holt_fit_MMN) |>
autoplot() +
labs(title = "ETS components")
# forecast
holt_fit_MMN |>
forecast(h = 5) |>
autoplot(lux_export)+
labs(title="Luxembourg export, ETS(MMN)")
library(fpp2)
head(books)
paperback <- books[,1]
times <- seq(1, dim(books)[1], 1)    # vector for time
books_df <- data.frame(books[, 1:2]) # Paperback and Hardcover as data.frame
books_tsibble <- books_df |>           # create tsibble object
mutate(Time = times, .before=1) |>
as_tsibble(index = Time)
books_tsibble
# plot
autoplot(books_tsibble) + labs(title = "Paperback books")
# ETS model, "AAdN"
model_AAdN <- books_tsibble |>
model(
`SES` = ETS(Paperback ~ error("A") + trend("Ad") + season("N"))
)
components(model_AAdN) |> print(n=31)
report(model_AAdN)
# Forecast
AAdN_fc <- model_AAdN |>
forecast(h=10)
AAdN_fc
# Plot data and forecast
AAdN_fc |>
autoplot(books_tsibble) +
geom_line(aes(y = .fitted), col="#D55E00",
data = augment(model_AAdN))
components(model_AAdN) |>
autoplot() +
labs(title = "ETS(A,Ad,N) components")
components(model_AAdN) |> print(n=31)
report(model_AAdN)
a <- unlist(report(model_AAdN))
# last l
l.30 <- a$SES.fit.states.l31         # 208.2084
# last b
b.30 <- a$SES.fit.states.b31         # 0.9943547
# alpha
alpha <- a$SES.fit.par.estimate1    # 0.03259223
# beta
beta <- a$SES.fit.par.estimate2     # 0.0001000242
# phi
phi <- a$SES.fit.par.estimate3      # 0.98
# sigma
sigma <- sqrt(a$SES.fit.fit.sigma2) # 34.9327
# set the random seed to have always the same random numbers generation
set.seed(3909966)
h.step <- 10     # 10âˆ’step ahead
l.vec <- numeric(h.step)
b.vec <- numeric(h.step)
y <- numeric (h.step)
## initialization of y_31, b_31 and l_31 (see ets table)
eps <- rnorm(n=1, mean=0 , sd=sigma)
y[1] <- l.30 + phi*b.30 + eps
l.vec[1] <- l.30 + phi*b.30 + alpha*eps
b.vec[1] <- phi*b.30 + beta*eps
## the loop for the next steps
for (h in 2:10) {
eps <- rnorm(n=1, mean=0, sd=sigma)
y[h] <- l.vec[h-1] + phi*b.vec[h-1] + eps
l.vec[h] <- l.vec[h-1] + phi*b.vec [h-1] + alpha*eps
b.vec[h] <- phi*b.vec[h-1] + beta*eps
}
plot(paperback, xlim=c(0,40), ylim=c(100,300))
points(y~c(31:40), type = "l" , lwd =2)
set.seed(123) # set the random seed to have always the same random numbers generation
h.step <- 10 # 10-step ahead
R <- 1000 # 1000 replicates
l.mat <- matrix(nr=h.step, nc=R)
b.mat <- matrix(nr=h.step, nc=R)
y <- matrix(nr=h.step, nc=R)
## initialization of y_31, b_31 and l_31
eps <- rnorm (n=R, mean=0 , sd=sigma)
y[1, ] <- l.30 + phi*b.30 + eps #first row
l.mat[1, ] <- l.30 + phi*b.30 + alpha*eps #first row
b.mat[1, ] <- phi*b.30 + beta*eps #first row
## the loop for the next steps
for(h in 2:10) {
eps <- rnorm(n=R, mean=0, sd=sigma)
y[h,] <- l.mat[h-1,] + phi*b.mat[h-1,] + eps
l.mat[h,] <- l.mat[h-1,] + phi*b.mat[h-1,] + alpha*eps
b.mat[h,] <- phi*b.mat[h-1,] + beta*eps
}
k <- 10 #paths to show in the plot (bounded by R)
plot(paperback, xlim=c(0, 40), ylim=c(100, 300))
for(j in c(1:k)) {
points(y[,j] ~ c(31:40), type="l", lwd=2)
}
## a.
apply(y, 1, quantile, probs=c(0.025, 0.975))
quantile(x = y[10,],probs = c(0.025,0.975)) #alternative (only for t+10)
## b.
y.tot <- apply(y[1:5, ], 2, sum)
hist(y.tot)
summary(y.tot)
## c.
mean((y[1,]>y[2,])&(y[2,]>y[3,])) #decrease next 3 days
mean((y[1,]>y[2,])&(y[2,]>y[3,]) == TRUE) #decrease next 3 days
mean((y[1,]<y[2,])&(y[2,]<y[3,])) #increase next 3 days
s <- 1:10
d <- diff(s)
diffinv(d, xi = 1)
d
s <- 1:10
d <- diff(s)
diffinv(d, lag = 1)
aus_production |>
autoplot(Electricity)  #Yes, these need transforming.
lambda <- aus_production |>
features(Electricity, guerrero) |>
pull(lambda_guerrero)
lambda
aus_production |>
autoplot(box_cox(Electricity, lambda))
aus_production |>
gg_tsdisplay(box_cox(Electricity, lambda) |>
difference(4), plot_type = "partial") #quarterly data
# TP8
# clean ws
rm(list=ls())
# pkg
library(fpp3)
library(xlsx)
library(ggplot2)
library(fpp2)
# TP8
# clean ws
rm(list=ls())
# pkg
library(fpp3)
library(xlsx)
library(ggplot2)
# ---------------- ex1
remove.packages("fpp2")
library(fpp3)
library(xlsx)
library(ggplot2)
data(books)
str(books)
?books
plot(books)
plot(books[,1], main = "Paperback")
?books
library(fpp2)
data(books)
str(books)
?books
plot(books)
plot(books[,1], main = "Paperback")
plot(books[,2], main = "Hardcover")
days <- seq(1, length.out = length(books[,1]), by = 1 ) # by 1 month
paperback <- as.numeric(books[,1] )
hardcover <- as.numeric(books[,2])
books_df <-
bind_cols(Dates = days) |>
bind_cols(Paperback = paperback) |>
bind_cols(Hardcover = hardcover)
books_df
ggplot(books_df, aes(Dates, Paperback)) +
geom_line(color = "blue") +
geom_line(aes(Dates, Hardcover), color = "red")+
labs(title = "Books sales")
?ses #fpp2, forecast package
paperback <- books[,1]
help("ses")
par(mfrow=c(2,2))
for(i in seq(0.01, 0.99, 0.1)){
model.ses = ses(paperback, alpha = i, initial = "simple", h = 1)
alpha_txt = paste("SES alpha:",i,sep=" ")
rmse = round(sqrt(sum(model.ses$residuals^2)/length(model.ses$residuals)),2)
# sse = round(sum(model.ses$residuals^2),2) not on the same scale
rmse_txt = paste("rmse:",rmse,sep=" ")
title_txt = paste(alpha_txt,rmse_txt, sep =" ")
plot(model.ses, main = title_txt, PI=FALSE)
lines(fitted(model.ses), lwd=2, col="red")
}
par(mfrow=c(5,2))
for(i in seq(0.01, 0.99, 0.1)){
model.ses = ses(paperback, alpha = i, initial = "simple", h = 1)
alpha_txt = paste("SES alpha:",i,sep=" ")
rmse = round(sqrt(sum(model.ses$residuals^2)/length(model.ses$residuals)),2)
# sse = round(sum(model.ses$residuals^2),2) not on the same scale
rmse_txt = paste("rmse:",rmse,sep=" ")
title_txt = paste(alpha_txt,rmse_txt, sep =" ")
plot(model.ses, main = title_txt, PI=FALSE)
lines(fitted(model.ses), lwd=2, col="red")
}
par(mfrow=c(1,2))
for(i in seq(0.01, 0.99, 0.1)){
model.ses = ses(paperback, alpha = i, initial = "simple", h = 1)
alpha_txt = paste("SES alpha:",i,sep=" ")
rmse = round(sqrt(sum(model.ses$residuals^2)/length(model.ses$residuals)),2)
# sse = round(sum(model.ses$residuals^2),2) not on the same scale
rmse_txt = paste("rmse:",rmse,sep=" ")
title_txt = paste(alpha_txt,rmse_txt, sep =" ")
plot(model.ses, main = title_txt, PI=FALSE)
lines(fitted(model.ses), lwd=2, col="red")
}
par(mfrow=c(1,2))
for(i in seq(0.01, 0.99, 0.1)){
model.ses = ses(paperback, alpha = i, initial = "simple", h = 1)
alpha_txt = paste("SES alpha:",i,sep=" ")
rmse = round(sqrt(sum(model.ses$residuals^2)/length(model.ses$residuals)),2)
# sse = round(sum(model.ses$residuals^2),2) not on the same scale
rmse_txt = paste("rmse:",rmse,sep=" ")
title_txt = paste(alpha_txt,rmse_txt, sep =" ")
plot(model.ses, main = title_txt, PI=FALSE)
lines(fitted(model.ses), lwd=2, col="red")
}
paperback
as_tsibble(paperback)
paperback_ts = as_tsibble(paperback)
paperback_ts = as_tsibble(paperback)
paperback_tsibble = as_tsibble(paperback)
paperback_tsibble = as_tsibble(paperback)
alpha_vals <- tibble(alpha = seq(0.1, 0.9, by = 0.1))
# Fit SES model for each alpha
models <- alpha_vals %>%
mutate(
fit = map(alpha, ~
paperback_tsibble %>%
model(SES = ETS(value ~ error("A") + trend("N") + season("N"),
fixed = list(alpha = .x)))
)
)
library(fpp3)
library(xlsx)
library(ggplot2)
library(fpp2)
library(tsibble)
library(fable)
library(fabletools)
library(dplyr)
library(ggplot2)
library(tidyr)
# Fit SES model for each alpha
models <- alpha_vals %>%
mutate(
fit = map(alpha, ~
paperback_tsibble %>%
model(SES = ETS(value ~ error("A") + trend("N") + season("N"),
fixed = list(alpha = .x)))
)
)
library(purrr)
par(mfrow=c(1,2))
paperback_tsibble = as_tsibble(paperback)
alpha_vals <- tibble(alpha = seq(0.1, 0.9, by = 0.1))
# Fit SES model for each alpha
models <- alpha_vals %>%
mutate(
fit = map(alpha, ~
paperback_tsibble %>%
model(SES = ETS(value ~ error("A") + trend("N") + season("N"),
fixed = list(alpha = .x)))
)
)
models
# Compute accuracy for each model
results <- models %>%
mutate(acc = map(fit, ~ accuracy(.x))) %>%
unnest(acc)
results
# Fit SES model for each alpha
models <- alpha_vals %>%
mutate(
fit = map(alpha, ~
paperback_tsibble %>%
model(SES = ETS(value ~ error("A") + trend("N") + season("N"),
fixed = list(alpha = .x)))
)
)
par(mfrow=c(1,2))
for(i in seq(0.01, 0.99, 0.1)){
model.ses = ses(paperback, alpha = i, initial = "simple", h = 1)
alpha_txt = paste("SES alpha:",i,sep=" ")
rmse = round(sqrt(sum(model.ses$residuals^2)/length(model.ses$residuals)),2)
# sse = round(sum(model.ses$residuals^2),2) not on the same scale
rmse_txt = paste("rmse:",rmse,sep=" ")
title_txt = paste(alpha_txt,rmse_txt, sep =" ")
plot(model.ses, main = title_txt, PI=FALSE)
lines(fitted(model.ses), lwd=2, col="red")
}
par(mfrow=c(1,1))
model_ses_simple = ses(paperback, initial = "simple", h = 40)
str(model_ses_simple)
summary(model_ses_simple)
plot(model_ses_simple, PI=FALSE)
lines(fitted(model_ses_simple), lwd=2, col="red")
model_ses_optimal = ses(paperback, initial = "optimal", h = 4)
summary(model_ses_optimal)
plot(model_ses_optimal, PI=FALSE)
lines(fitted(model_ses_optimal), lwd=2, col="red")
?holt
par(mfrow=c(2,2))
for(i in seq(0.2,0.8,0.2)){
model.holt = holt(paperback, alpha = i, beta = i,initial = "optimal", h = 1)
alpha_beta_txt = paste("Holt's alpha and beta:", i, sep=" ")
rmse = round(sqrt(sum(model.holt$residuals^2)/length(model.holt$residuals)),2)
rmse_txt = paste("rmse:", rmse, sep=" ")
title_txt = paste(alpha_beta_txt, rmse_txt, sep =" ")
plot(model.holt, main = title_txt, PI=FALSE)
lines(fitted(model.holt), lwd=2, col="red")
}
par(mfrow=c(1,1))
model.holt = holt(paperback, initial = "optimal", h=40)
summary(model.holt)
plot(model.holt)
lines(fitted(model.holt), lwd=2, col="red")
model.holt = holt(paperback, initial = "optimal", h=4, damped=TRUE) #phi, beta, alpha (if null are estimated)
summary(model.holt)
plot(model.holt)
lines(fitted(model.holt), lwd=2, col="red")
?holt
model.ets = ets(y=paperback, model="AAN", damped=TRUE)
summary(model.ets)
plot(model.ets) # decomposition
plot(forecast(model.ets, h=4), PI=FALSE)
lines(fitted(model.ets), lwd=2, col="red")
#----------------------------------------------
fit <- as_tsibble(paperback) %>%
model(
holt_fixed = ETS(value ~ error("A") + trend("A") + season("N"),
fixed = list(alpha = 0.1, beta = 0.05))
)
#----------------------------------------------
fit <- as_tsibble(paperback) %>%
model(
holt_fixed =  holt(paperback, alpha = i, beta = i,initial = "optimal", h = 1)
)
?fable::ETS
#----------------------------------------------
fit <- as_tsibble(paperback) %>%
model(
holt_fixed =  ?fable::ETS(error = "A", trend = "A", season = "N", alpha = 0.2, beta = 0.2)
)
#----------------------------------------------
fit <- as_tsibble(paperback) %>%
model(
holt_fixed =  fable::ETS(error = "A", trend = "A", season = "N", alpha = 0.2, beta = 0.2)
)
#----------------------------------------------
fit <- as_tsibble(paperback) %>%
model(
holt_fixed =  fable::ETS( trend = "A", season = "N", alpha = 0.2, beta = 0.2)
)
#----------------------------------------------
fit <- as_tsibble(paperback) %>%
model(
holt_fixed =  fable::ETS(  season = "N", alpha = 0.2, beta = 0.2)
)
fit <- df %>%
model(
holt_fixed = ETS(value ~ error("A") + trend("A") + season("N"),
fixed = list(alpha = 0.1, beta = 0.05))
)
fit <- df %>%
model(
holt_fixed = ETS(value ~ error("A") + trend("A") + season("N"),
fixed = list(alpha = 0.1, beta = 0.05))
)
fit <-  as_tsibble(paperback) %>%
model(
holt_fixed = ETS(value ~ error("A") + trend("A") + season("N"),
fixed = list(alpha = 0.1, beta = 0.05))
)
?holt
par(mfrow=c(2,2))
for(i in seq(0.2,0.8,0.2)){
model.holt = holt(paperback, alpha = i, beta = i,initial = "optimal", h = 1)
alpha_beta_txt = paste("Holt's alpha and beta:", i, sep=" ")
rmse = round(sqrt(sum(model.holt$residuals^2)/length(model.holt$residuals)),2)
rmse_txt = paste("rmse:", rmse, sep=" ")
title_txt = paste(alpha_beta_txt, rmse_txt, sep =" ")
plot(model.holt, main = title_txt, PI=FALSE)
lines(fitted(model.holt), lwd=2, col="red")
}
par(mfrow=c(1,1))
model.holt = holt(paperback, initial = "optimal", h=40)
summary(model.holt)
plot(model.holt)
lines(fitted(model.holt), lwd=2, col="red")
rm(list=ls())
# Set seed for reproducibility
set.seed(123)
# Parameters
n <- 500           # Length of time series
m_realizations <- 100  # Number of realizations for empirical statistics
# Simulate a single realization of white noise
X <- rnorm(n, mean = 0, sd = 1)
# Plot the time series
plot(1:n, X, type = "l", col = "blue", lwd = 1.5,
main = "Strongly Stationary Process: White Noise",
xlab = "Time", ylab = "X_t")
# Compute empirical mean and variance over multiple realizations
means <- numeric(n)
vars <- numeric(n)
for(t in 1:n){
X_mult <- matrix(rnorm(n * m_realizations, mean = 0, sd = 1), nrow = m_realizations)
means[t] <- mean(X_mult[, t])
vars[t] <- var(X_mult[, t])
}
# Plot mean over time
plot(1:n, means, type = "l", col = "darkgreen", lwd = 1.5,
main = "Empirical Mean over Time",
xlab = "Time", ylab = "Mean")
# Plot variance over time
plot(1:n, vars, type = "l", col = "purple", lwd = 1.5,
main = "Empirical Variance over Time",
xlab = "Time", ylab = "Variance")
# Compute and plot empirical autocovariance
acf(X, type = "covariance", main = "Empirical Autocovariance Function", col = "red")
set.seed(12345)
n <- 500      # number of time points
n <- 500      # number of time points
Nrep <- 1000  # number of independent realizations (for ensemble statistics)
# --- 1) Simulate a single realization ---
U_single <- runif(1, min = -pi, max = pi)   # sample one U
tvec <- 1:n
X_single <- cos(tvec * U_single)
# Plot the single realization
plot(tvec, X_single, type='l', main=paste("One realization of X_t = cos(t U), U =", round(U_single,3)),
xlab="t", ylab="X_t")
# --- 2) Generate multiple realizations ---
U_vec <- runif(Nrep, min = -pi, max = pi)      # Nrep independent U's
# Create matrix: each row is a realization
X_mat <- t(sapply(U_vec, function(u) cos(tvec * u)))   # Nrep x n
View(X_mat)
dim(X_mat)
# Empirical mean and variance at each t
mean_t <- colMeans(X_mat)
var_t  <- apply(X_mat, 2, var)
# Plot empirical mean
plot(tvec, mean_t, type='l', main="Empirical mean of X_t across realizations",
xlab="t", ylab="Mean(X_t)")
# Plot empirical variance
plot(tvec, var_t, type='l', main="Empirical variance of X_t across realizations",
xlab="t", ylab="Var(X_t)")
# --- 3) Show weak stationarity ---
# The process is weakly stationary if mean is constant and autocovariance depends only on lag
lag_max <- 20
emp_autocov <- function(h) {
if(h==0) return(mean(colMeans(X_mat^2)))
m <- 1:(n-h)
mean(rowMeans(X_mat[, m] * X_mat[, m+h]))
}
emp_gamma <- sapply(0:lag_max, emp_autocov)
# Plot empirical autocovariance vs lag
plot(0:lag_max, emp_gamma, type='h', main="Empirical autocovariance function",
xlab="lag h", ylab="Cov(X_t, X_{t+h})")
# ---------------Exercise 3: random walk
set.seed(12345)
n <- 500      # number of time points
Nrep <- 1000  # number of independent realizations
# --- 1) Simulate a single realization ---
X <- rnorm(n)         # i.i.d. standard normal increments
S <- cumsum(X)        # random walk
plot(1:n, S, type='l', main="Single realization of a random walk",
xlab="t", ylab="S_t")
# --- 2) Generate multiple realizations ---
X_mat <- matrix(rnorm(n * Nrep), nrow=Nrep, ncol=n)   # each row is a realization of increments
S_mat <- t(apply(X_mat, 1, cumsum))                  # random walks
View(S_mat)
# Empirical mean and variance at each t
mean_t <- colMeans(S_mat)
var_t  <- apply(S_mat, 2, var)
# Plot empirical mean
plot(1:n, mean_t, type='l', main="Empirical mean of S_t across realizations",
xlab="t", ylab="Mean(S_t)")
# Plot empirical variance
plot(1:n, var_t, type='l', main="Empirical variance of S_t across realizations",
xlab="t", ylab="Var(S_t)")
