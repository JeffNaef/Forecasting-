cat("80% Quantile Score:", round(qs_mean,3), "\n")
cat("RMSE (mean forecast):", round(rmse_mean,3), "\n")
cat("Quantile score (mean forecast, alpha=0.8):", round(qs_mean_forecast,3), "\n\n")
cat("RMSE (80% quantile forecast):", round(rmse_q80,3), "\n")
cat("Quantile score (80% quantile forecast, alpha=0.8):", round(qs_q80,3), "\n")
cat("Quantile score (80% quantile forecast, alpha=0.8):", round(qs_mean,3), "\n")
cat("RMSE (80% quantile forecast):", round(rmse_q80,3), "\n")
cat("Quantile score (80% quantile forecast, alpha=0.8):", round(qs_mean,3), "\n")
cat("RMSE (mean forecast):", round(rmse_mean,3), "\n")
cat("Quantile score (mean forecast, alpha=0.8):", round(qs_mean_forecast,3), "\n\n")
rm(list=ls())
set.seed(1234)
# exercise 1
n <- 1000
phi <- 0.7
sigma <- 1
# first value from stationary distribution
y <- numeric(n)
y[1] <- rnorm(1, 0, sigma / sqrt(1 - phi^2))
for(t in 2:n){
y[t] <- phi * y[t-1] + rnorm(1, 0, sigma)
}
p_train <- 0.7
n_train <- floor(n*p_train)
y_train <- y[1:n_train]
y_test <- y[(n_train+1):n]
h <- length(y_test)
fit <- Arima(y_train, order = c(1,0,0), include.mean = FALSE)
pred <- forecast(fit, h = h, level = 80)  # 80% quantile
q80 <- pred$upper[,1]  # 80% quantile from forecast
alpha <- 0.8
# compute rmse and quantile score on mean
# RMSE for mean forecast
rmse_mean <- sqrt(mean((y_test - pred$mean)^2))
# Quantile score for mean forecast (should not be optimal for alpha=0.8)
qs_mean_forecast <- (alpha-1)*(y_test - pred$mean)*(y_test < pred$mean) +
alpha*(y_test - pred$mean)*(y_test >= pred$mean)
qs_mean_forecast <- mean(qs_mean_forecast)
# compute rmse and quantile score on 80 % quantile
rmse_q80 <- sqrt(mean((y_test - q80)^2))
qs <- (alpha-1)*(y_test - q80)*(y_test < q80) +
alpha*(y_test - q80)*(y_test >= q80)
qs_mean <- mean(qs)
plot(y, type="l", col="black", main="Mean vs 80% Quantile Forecast",
ylab="y", xlab="t")
lines(n_train + 1:h, pred$mean, col="blue", lwd=2)
lines(n_train + 1:h, q80, col="red", lwd=2, lty=2)
legend("topleft", legend=c("Observed","Forecast mean","80% Quantile"),
col=c("black","blue","red"), lty=c(1,1,2), lwd=c(1,2,2))
cat("RMSE (mean forecast):", round(rmse_mean,3), "\n")
cat("Quantile score (mean forecast, alpha=0.8):", round(qs_mean_forecast,3), "\n\n")
cat("RMSE (80% quantile forecast):", round(rmse_q80,3), "\n")
cat("Quantile score (80% quantile forecast, alpha=0.8):", round(qs_mean,3), "\n")
# exercise 1
n <- 1000
phi <- 0.7
sigma <- 1
# first value from stationary distribution
y <- numeric(n)
y[1] <- rnorm(1, 0, sigma / sqrt(1 - phi^2))
for(t in 2:n){
y[t] <- phi * y[t-1] + rnorm(1, 0, sigma)
}
p_train <- 0.7
n_train <- floor(n*p_train)
y_train <- y[1:n_train]
y_test <- y[(n_train+1):n]
h <- length(y_test)
fit <- Arima(y_train, order = c(1,0,0), include.mean = FALSE)
pred <- forecast(fit, h = h, level = 80)  # 80% quantile
q80 <- pred$upper[,1]  # 80% quantile from forecast
alpha <- 0.8
rm(list=ls())
# Simulation
B <- 500
n=500
phi <- c(.9, -.8)
sigma_eps <- .01
p_training = 0.7
alpha <- 0.8  # 80% quantile
# create mat for storing results
mat_results <- matrix(NA, nrow = B, ncol = 6)
for(b in seq(B)){
set.seed(1234+b)
#generate y
y = arima.sim(model = list(ar = phi), n = n, sd = sigma_eps)
# split in training and test and proportion given
y_train = y[1:floor(n*p_training)]
y_test = y[(floor(n*p_training)+1):n]
# fit AR1 model
fit_ar1 <- Arima(y_train, order = c(1,0,0), include.mean = FALSE)
# fit AR2 model
fit_ar2 <- Arima(y_train, order = c(2,0,0), include.mean = FALSE)
# predict on test set with both model
pred_ar1 <- forecast(fit_ar1, h = length(y_test))
pred_ar2 <- forecast(fit_ar2, h = length(y_test))
# compute RMSE for both models
rmse_ar1 <- sqrt(mean((y_test - pred_ar1$mean)^2))
rmse_ar2 <- sqrt(mean((y_test - pred_ar2$mean)^2))
# compute the MAE for both models
mae_ar1 <- mean(abs(y_test - pred_ar1$mean))
mae_ar2 <- mean(abs(y_test - pred_ar2$mean))
# 80% quantile forecasts
q80_ar1 <- pred_ar1$upper[,1]
q80_ar2 <- pred_ar2$upper[,1]
# Quantile score
qs_ar1 <- (alpha-1) * (y_test - q80_ar1) * (y_test < q80_ar1) +
(alpha) * (y_test - q80_ar1) * (y_test >= q80_ar1)
qs_ar2 <-  (alpha-1) * (y_test - q80_ar2) * (y_test < q80_ar2) +
(alpha) * (y_test - q80_ar2) * (y_test >= q80_ar2)
# compute mean score qantile score
mean_qs_ar1 = mean(qs_ar1)
mean_qs_ar2 = mean(qs_ar2)
# store results in matrix
mat_results[b, ] = c(rmse_ar1, rmse_ar2, mae_ar1, mae_ar2, mean_qs_ar1, mean_qs_ar2)
cat(paste0(b, "\n"))
}
# plot results
colnames(mat_results) <- c("RMSE_AR1", "RMSE_AR2", "MAE_AR1", "MAE_AR2", "QS80_AR1", "QS80_AR2")
# boxplot comparing ar1 vs ar 2 for each metric
boxplot(mat_results[,1:2], main = "RMSE comparison AR1 vs AR2", names = c("AR1", "AR2"))
boxplot(mat_results[,3:4], main = "MAE comparison AR1 vs AR2", names = c("AR1", "AR2"))
boxplot(mat_results[,5:6], main = "QS80 comparison AR1 vs AR2", names = c("AR1", "AR2"))
rm(list=ls())
n <- 200
phi <- 0.6    # AR coefficient
theta <- 0.3  # MA coefficient
sigma <- 1
y <- arima.sim(n = n, list(ar = phi, ma = theta), sd = sigma)
# -----------------------------
# 2. Split train/test
# -----------------------------
p_train <- 0.7
n_train <- floor(n * p_train)
y_train <- y[1:n_train]
y_test <- y[(n_train+1):n]
h <- length(y_test)
# -----------------------------
# 3. Fit ARMA(1,1) model
# -----------------------------
fit <- Arima(y_train, order = c(1,0,1), include.mean = FALSE)
# -----------------------------
# 4. Bootstrap future paths
# -----------------------------
B <- 500  # number of bootstrap paths
boot_preds <- matrix(NA, nrow = h, ncol = B)
for(b in 1:B){
boot_path <- simulate(fit, nsim = h, bootstrap = TRUE)
boot_preds[,b] <- boot_path
}
# -----------------------------
# 5. Compute mean and 80% quantile forecasts from bootstrap
# -----------------------------
pred_mean <- apply(boot_preds, 1, mean)
alpha <- 0.8
pred_q80 <- apply(boot_preds, 1, function(x) quantile(x, probs = alpha))
# -----------------------------
# 6. Compute RMSE and MAE
# -----------------------------
rmse_mean <- sqrt(mean((y_test - pred_mean)^2))
mae_mean  <- mean(abs(y_test - pred_mean))
rmse_q80 <- sqrt(mean((y_test - pred_q80)^2))
mae_q80  <- mean(abs(y_test - pred_q80))
cat("Mean forecast - RMSE:", round(rmse_mean,3), "MAE:", round(mae_mean,3), "\n")
cat("80% Quantile forecast - RMSE:", round(rmse_q80,3), "MAE:", round(mae_q80,3), "\n")
# -----------------------------
# 5. Compute mean and 80% quantile forecasts from bootstrap
# -----------------------------
pred_mean <- apply(boot_preds, 1, mean)
alpha <- 0.9
pred_q80 <- apply(boot_preds, 1, function(x) quantile(x, probs = alpha))
alpha <- 0.5
# -----------------------------
# 5. Compute mean and 80% quantile forecasts from bootstrap
# -----------------------------
pred_mean <- apply(boot_preds, 1, mean)
alpha <- 0.5
pred_q <- apply(boot_preds, 1, function(x) quantile(x, probs = alpha))
alpha <- 0.95
pred_q <- apply(boot_preds, 1, function(x) quantile(x, probs = alpha))
pred_q_upper <- apply(boot_preds, 1, function(x) quantile(x, probs = alpha))
alpha <- 0.90
# -----------------------------
# 5. Compute mean and 80% quantile forecasts from bootstrap
# -----------------------------
pred_mean <- apply(boot_preds, 1, mean)
alpha <- 0.90
pred_q_upper <- apply(boot_preds, 1, function(x) quantile(x, probs = alpha/2))
pred_q_lower <- apply(boot_preds, 1, function(x) quantile(x, probs = 1-alpha/2))
plot(y, type="l", col="black", main="Bootstrap Forecasts with 90% Prediction Band",
ylab="y", xlab="t")
# plot bootstrap paths
for(b in 1:B){
lines(n_train + 1:h, boot_preds[,b], col=rgb(0,0,0,alpha=0.05))
}
plot(y, type="l", col="white", main="Bootstrap Forecasts with 90% Prediction Band",
ylab="y", xlab="t")
plot(y, type="l", col="white", main="Bootstrap Forecasts with 90% Prediction Band",
ylab="y", xlab="t")
lines(y[1:n_train])
# plot bootstrap paths
for(b in 1:B){
lines(n_train + 1:h, boot_preds[,b], col=rgb(0,0,0,alpha=0.05))
}
plot(y, type="l", col="white", main="Bootstrap Forecasts with 90% Prediction Band",
ylab="y", xlab="t", ylim=c(-5,5))
lines(y[1:n_train])
# plot bootstrap paths
for(b in 1:B){
lines(n_train + 1:h, boot_preds[,b], col=rgb(0,0,0,alpha=0.05))
}
# mean forecast
lines(n_train + 1:h, pred_mean, col="blue", lwd=2)
# quantile forecast band
lines(n_train + 1:h, pred_q_upper, col="red", lwd=2, lty=2)
lines(n_train + 1:h, pred_q_lower, col="red", lwd=2, lty=2)
pred_mean <- apply(boot_preds, 1, mean)
alpha <- .1
pred_q_upper <- apply(boot_preds, 1, function(x) quantile(x, probs = alpha/2))
pred_q_lower <- apply(boot_preds, 1, function(x) quantile(x, probs = 1-alpha/2))
plot(y, type="l", col="white", main="Bootstrap Forecasts with 90% Prediction Band",
ylab="y", xlab="t", ylim=c(-5,5))
lines(y[1:n_train])
# plot bootstrap paths
for(b in 1:B){
lines(n_train + 1:h, boot_preds[,b], col=rgb(0,0,0,alpha=0.05))
}
# mean forecast
lines(n_train + 1:h, pred_mean, col="blue", lwd=2)
# quantile forecast band
lines(n_train + 1:h, pred_q_upper, col="red", lwd=2, lty=2)
lines(n_train + 1:h, pred_q_lower, col="red", lwd=2, lty=2)
# shaded area for prediction band
polygon(c(n_train + 1:h, rev(n_train + 1:h)),
c(pred_q_upper, rev(pred_q_lower)),
col=rgb(1,0,0,alpha=0.2), border=NA)
legend("topleft",
legend=c("Observed","Mean forecast","90% Prediction Band"),
col=c("black","blue","red"), lty=c(1,1,2), lwd=c(1,2,2))
legend("topleft",
legend=c("Observed","Mean forecast","90% Prediction Band"),
col=c("black","blue","red"), lty=c(1,1,2), lwd=c(1,2,2), bty="n")
rm(list=ls())
n <- 200
phi <- 0.6
theta <- 0.3
sigma <- 1
y <- arima.sim(n = n, list(ar = phi, ma = theta), sd = sigma)
p_train <- 0.7
n_train <- floor(n * p_train)
y_train <- y[1:n_train]
y_test <- y[(n_train+1):n]
h <- length(y_test)
fit <- Arima(y_train, order = c(1,0,1), include.mean = FALSE)
B <- 500  # number of bootstrap paths
boot_preds <- matrix(NA, nrow = h, ncol = B)
for(b in 1:B){
boot_path <- simulate(fit, nsim = h, bootstrap = TRUE)
boot_preds[,b] <- boot_path
}
pred_mean <- apply(boot_preds, 1, mean)
alpha <- .1
pred_q_upper <- apply(boot_preds, 1, function(x) quantile(x, probs = alpha/2))
pred_q_lower <- apply(boot_preds, 1, function(x) quantile(x, probs = 1-alpha/2))
plot(y, type="l", col="white", main="Bootstrap Forecasts with 90% Prediction Band",
ylab="y", xlab="t", ylim=c(-5,5))
lines(y[1:n_train])
# plot bootstrap paths
for(b in 1:B){
lines(n_train + 1:h, boot_preds[,b], col=rgb(0,0,0,alpha=0.05))
}
# mean forecast
lines(n_train + 1:h, pred_mean, col="blue", lwd=2)
# quantile forecast band
lines(n_train + 1:h, pred_q_upper, col="red", lwd=2, lty=2)
lines(n_train + 1:h, pred_q_lower, col="red", lwd=2, lty=2)
# shaded area for prediction band
polygon(c(n_train + 1:h, rev(n_train + 1:h)),
c(pred_q_upper, rev(pred_q_lower)),
col=rgb(1,0,0,alpha=0.2), border=NA)
legend("topleft",
legend=c("Observed","Mean forecast","90% Prediction Band"),
col=c("black","blue","red"), lty=c(1,1,2), lwd=c(1,2,2), bty="n")
rmse_mean <- sqrt(mean((y_test - pred_mean)^2))
rmse_q_upper <- sqrt(mean((y_test - pred_q_upper)^2))
rmse_mean <- sqrt(mean((y_test - pred_mean)^2))
rmse_q_upper <- sqrt(mean((y_test - pred_q_upper)^2))
rmse_mean
rmse_q_upper
# quantile score on predicted quantile
qs_upper <- (alpha/2 - 1)*(y_test - pred_q_upper)*(y_test < pred_q_upper) +
(alpha/2)*(y_test - pred_q_upper)*(y_test >= pred_q_upper)
qs_upper
# quantile score on predicted quantile
qs_upper <- mean(
(alpha/2 - 1)*(y_test - pred_q_upper)*(y_test < pred_q_upper) +
(alpha/2)*(y_test - pred_q_upper)*(y_test >= pred_q_upper)
)
# quantile score on predicted quantile
mean_qs_upper <- mean(
(alpha/2 - 1)*(y_test - pred_q_upper)*(y_test < pred_q_upper) +
(alpha/2)*(y_test - pred_q_upper)*(y_test >= pred_q_upper)
)
rmse_mean <- sqrt(mean((y_test - pred_mean)^2))
rmse_q_upper <- sqrt(mean((y_test - pred_q_upper)^2))
# quantile score on predicted quantile
mean_qs_upper <- mean(
(alpha/2 - 1)*(y_test - pred_q_upper)*(y_test < pred_q_upper) +
(alpha/2)*(y_test - pred_q_upper)*(y_test >= pred_q_upper)
)
# quantile score on mean
mean_qs_mean <- mean(
(0.5 - 1)*(y_test - pred_mean)*(y_test < pred_mean) +
(0.5)*(y_test - pred_mean)*(y_test >= pred_mean)
)
# print results
cat(paste0("RMSE on mean forecast: ", round(rmse_mean,4), "\n"))
cat(paste0("RMSE on 5% quantile forecast: ", round(rmse_q_upper,4), "\n"))
rm(list=ls())
n <- 200
phi <- 0.6
theta <- 0.3
sigma <- 1
y <- arima.sim(n = n, list(ar = phi, ma = theta), sd = sigma)
p_train <- 0.7
n_train <- floor(n * p_train)
y_train <- y[1:n_train]
y_test <- y[(n_train+1):n]
h <- length(y_test)
fit <- Arima(y_train, order = c(1,0,1), include.mean = FALSE)
B <- 500  # number of bootstrap paths
boot_preds <- matrix(NA, nrow = h, ncol = B)
for(b in 1:B){
boot_path <- simulate(fit, nsim = h, bootstrap = TRUE)
boot_preds[,b] <- boot_path
}
pred_mean <- apply(boot_preds, 1, mean)
alpha <- .1
pred_q_upper <- apply(boot_preds, 1, function(x) quantile(x, probs = 1- alpha/2))
pred_q_lower <- apply(boot_preds, 1, function(x) quantile(x, probs = alpha/2))
plot(y, type="l", col="white", main="Bootstrap Forecasts with 90% Prediction Band",
ylab="y", xlab="t", ylim=c(-5,5))
lines(y[1:n_train])
# plot bootstrap paths
for(b in 1:B){
lines(n_train + 1:h, boot_preds[,b], col=rgb(0,0,0,alpha=0.05))
}
# mean forecast
lines(n_train + 1:h, pred_mean, col="blue", lwd=2)
# quantile forecast band
lines(n_train + 1:h, pred_q_upper, col="red", lwd=2, lty=2)
lines(n_train + 1:h, pred_q_lower, col="red", lwd=2, lty=2)
# shaded area for prediction band
polygon(c(n_train + 1:h, rev(n_train + 1:h)),
c(pred_q_upper, rev(pred_q_lower)),
col=rgb(1,0,0,alpha=0.2), border=NA)
legend("topleft",
legend=c("Observed","Mean forecast","90% Prediction Band"),
col=c("black","blue","red"), lty=c(1,1,2), lwd=c(1,2,2), bty="n")
rmse_mean <- sqrt(mean((y_test - pred_mean)^2))
rmse_q_upper <- sqrt(mean((y_test - pred_q_upper)^2))
# quantile score on predicted quantile
mean_qs_upper <- mean(
(1-alpha/2 - 1)*(y_test - pred_q_upper)*(y_test < pred_q_upper) +
(1-alpha/2)*(y_test - pred_q_upper)*(y_test >= pred_q_upper)
)
# quantile score on mean
mean_qs_mean <- mean(
(0.5 - 1)*(y_test - pred_mean)*(y_test < pred_mean) +
(0.5)*(y_test - pred_mean)*(y_test >= pred_mean)
)
# print results
cat(paste0("RMSE on mean forecast: ", round(rmse_mean,4), "\n"))
cat(paste0("RMSE on 95% quantile forecast: ", round(rmse_q_upper,4), "\n"))
# print results
cat(paste0("RMSE on mean forecast: ", round(rmse_mean,4), "\n"))
cat(paste0("Mean Quantile Score on mean forecast: ", round(mean_qs_mean,4), "\n"))
cat(paste0("RMSE on 95% quantile forecast: ", round(rmse_q_upper,4), "\n"))
cat(paste0("Mean Quantile Score on 5% quantile forecast: ", round(mean_qs_upper,4), "\n"))
# quantile score on mean
mean_qs_mean <- mean(
(0.95 - 1)*(y_test - pred_mean)*(y_test < pred_mean) +
(0.95)*(y_test - pred_mean)*(y_test >= pred_mean)
)
mean_qs_mean
# quantile score on mean
mean_qs_mean <- mean(
(0.5 - 1)*(y_test - pred_mean)*(y_test < pred_mean) +
(0.5)*(y_test - pred_mean)*(y_test >= pred_mean)
)
mean_qs_mean
rm(list=ls())
n <- 200
phi <- 0.6
theta <- 0.3
sigma <- 1
y <- arima.sim(n = n, list(ar = phi, ma = theta), sd = sigma)
p_train <- 0.7
n_train <- floor(n * p_train)
y_train <- y[1:n_train]
y_test <- y[(n_train+1):n]
h <- length(y_test)
fit <- Arima(y_train, order = c(1,0,1), include.mean = FALSE)
B <- 500  # number of bootstrap paths
boot_preds <- matrix(NA, nrow = h, ncol = B)
for(b in 1:B){
boot_path <- simulate(fit, nsim = h, bootstrap = TRUE)
boot_preds[,b] <- boot_path
}
pred_mean <- apply(boot_preds, 1, mean)
alpha <- .1
pred_q_upper <- apply(boot_preds, 1, function(x) quantile(x, probs = 1- alpha/2))
pred_q_lower <- apply(boot_preds, 1, function(x) quantile(x, probs = alpha/2))
plot(y, type="l", col="white", main="Bootstrap Forecasts with 90% Prediction Band",
ylab="y", xlab="t", ylim=c(-5,5))
lines(y[1:n_train])
# plot bootstrap paths
for(b in 1:B){
lines(n_train + 1:h, boot_preds[,b], col=rgb(0,0,0,alpha=0.05))
}
# mean forecast
lines(n_train + 1:h, pred_mean, col="blue", lwd=2)
# quantile forecast band
lines(n_train + 1:h, pred_q_upper, col="red", lwd=2, lty=2)
lines(n_train + 1:h, pred_q_lower, col="red", lwd=2, lty=2)
# shaded area for prediction band
polygon(c(n_train + 1:h, rev(n_train + 1:h)),
c(pred_q_upper, rev(pred_q_lower)),
col=rgb(1,0,0,alpha=0.2), border=NA)
legend("topleft",
legend=c("Observed","Mean forecast","90% Prediction Band"),
col=c("black","blue","red"), lty=c(1,1,2), lwd=c(1,2,2), bty="n")
rmse_mean <- sqrt(mean((y_test - pred_mean)^2))
rmse_q_upper <- sqrt(mean((y_test - pred_q_upper)^2))
# rmse on predicted mean
rmse_mean <- sqrt(mean((y_test - pred_mean)^2))
rmse_q_upper <- sqrt(mean((y_test - pred_q_upper)^2))
# quantile score on predicted quantile
mean_qs_upper <- mean(
(1-alpha/2 - 1)*(y_test - pred_q_upper)*(y_test < pred_q_upper) +
(1-alpha/2)*(y_test - pred_q_upper)*(y_test >= pred_q_upper)
)
# quantile score on mean
mean_qs_mean <- mean(
(0.5 - 1)*(y_test - pred_mean)*(y_test < pred_mean) +
(0.5)*(y_test - pred_mean)*(y_test >= pred_mean)
)
# print results
cat(paste0("RMSE on mean forecast: ", round(rmse_mean,4), "\n"))
cat(paste0("Mean Quantile Score on mean forecast: ", round(mean_qs_mean,4), "\n"))
cat(paste0("RMSE on 95% quantile forecast: ", round(rmse_q_upper,4), "\n"))
cat(paste0("Mean Quantile Score on 95% quantile forecast: ", round(mean_qs_upper,4), "\n"))
n <- 200
phi <- 0.6
theta <- 0.3
sigma <- 1
y <- arima.sim(n = n, list(ar = phi, ma = theta), sd = sigma)
p_train <- 0.7
n_train <- floor(n * p_train)
y_train <- y[1:n_train]
y_test <- y[(n_train+1):n]
h <- length(y_test)
fit <- Arima(y_train, order = c(1,0,1), include.mean = FALSE)
B <- 500  # number of bootstrap paths
boot_preds <- matrix(NA, nrow = h, ncol = B)
for(b in 1:B){
boot_path <- simulate(fit, nsim = h, bootstrap = TRUE)
boot_preds[,b] <- boot_path
}
pred_mean <- apply(boot_preds, 1, mean)
alpha <- .1
pred_q_upper <- apply(boot_preds, 1, function(x) quantile(x, probs = 1- alpha/2))
pred_q_lower <- apply(boot_preds, 1, function(x) quantile(x, probs = alpha/2))
plot(y, type="l", col="white", main="Bootstrap Forecasts with 90% Prediction Band",
ylab="y", xlab="t", ylim=c(-5,5))
lines(y[1:n_train])
# plot bootstrap paths
for(b in 1:B){
lines(n_train + 1:h, boot_preds[,b], col=rgb(0,0,0,alpha=0.05))
}
# mean forecast
lines(n_train + 1:h, pred_mean, col="blue", lwd=2)
# quantile forecast band
lines(n_train + 1:h, pred_q_upper, col="red", lwd=2, lty=2)
lines(n_train + 1:h, pred_q_lower, col="red", lwd=2, lty=2)
# shaded area for prediction band
polygon(c(n_train + 1:h, rev(n_train + 1:h)),
c(pred_q_upper, rev(pred_q_lower)),
col=rgb(1,0,0,alpha=0.2), border=NA)
# mean forecast
lines(n_train + 1:h, pred_mean, col="blue", lwd=2)
legend("topleft",
legend=c("Observed","Mean forecast","90% Prediction Band"),
col=c("black","blue","red"), lty=c(1,1,2), lwd=c(1,2,2), bty="n")
# rmse on predicted mean
rmse_mean <- sqrt(mean((y_test - pred_mean)^2))
rmse_q_upper <- sqrt(mean((y_test - pred_q_upper)^2))
# quantile score on predicted quantile
mean_qs_upper <- mean(
(1-alpha/2 - 1)*(y_test - pred_q_upper)*(y_test < pred_q_upper) +
(1-alpha/2)*(y_test - pred_q_upper)*(y_test >= pred_q_upper)
)
# quantile score on mean
mean_qs_mean <- mean(
(0.5 - 1)*(y_test - pred_mean)*(y_test < pred_mean) +
(0.5)*(y_test - pred_mean)*(y_test >= pred_mean)
)
# print results
cat(paste0("RMSE on mean forecast: ", round(rmse_mean,4), "\n"))
cat(paste0("Mean Quantile Score on mean forecast: ", round(mean_qs_mean,4), "\n"))
cat(paste0("RMSE on 95% quantile forecast: ", round(rmse_q_upper,4), "\n"))
cat(paste0("Mean Quantile Score on 95% quantile forecast: ", round(mean_qs_upper,4), "\n"))
