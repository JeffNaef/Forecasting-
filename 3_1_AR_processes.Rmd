---
title: "Analysis of AR(p) Processes:"
output: html_document
date: "2025-07-27"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 10)
library(ggplot2)
library(tsibble)
library(feasts)
library(patchwork)
library(dplyr)
library(stringr)
library(tidyr)
set.seed(123)
```

# Introduction to AR Processes

Autoregressive (AR) processes are fundamental building blocks in time series analysis. An AR(p) process is defined as:

$$Y_t = \phi_0 + \phi_1 Y_{t-1} + \phi_2 Y_{t-2} + \ldots + \phi_p Y_{t-p} + u_t$$

where $u_t \sim WN(0, \sigma^2)$ (white noise).

## Key Properties


- **Stationarity**: Requires roots of characteristic equation outside unit circle

- **Autocorrelation**: Exponential decay (AR(1)) or sinusoidal patterns (AR(2))

- **Partial Autocorrelation**: Cuts off after lag p

---

# AR(1) Process Analysis

## Mathematical Foundation

An AR(1) process has the form:
$$Y_t = \phi_0 + \phi_1 Y_{t-1} + u_t$$

**Stationarity condition**: $|\phi_1| < 1$

**Key properties**:


- Mean: $\mathbb{E}[Y_t] = \frac{\phi_0}{1-\phi_1}$

- Variance: $Var(Y_t) = \frac{\sigma^2}{1-\phi^2}$

- Autocorrelation: $\rho(Y_t, Y_{s}) = \phi^{|t-s|}$

## Simulation of Different AR(1) Processes

```{r ar1_simulation}
# Function to simulate AR(1) process
simulate_ar1 <- function(n, phi, c = 0, sigma = 1) {
  y <- numeric(n)
  u <- rnorm(n, 0, sigma)
  
  # Starting value (unconditional mean)
  y[1] <- c / (1 - phi) + u[1] / sqrt(1 - phi^2)
  
  for (t in 2:n) {
    y[t] <- c + phi * y[t-1] + u[t]
  }
  
  return(y)
}

# Simulate different AR(1) processes
n <- 300
ar1_data <- tibble(
  time = rep(1:n, 4),
  series = rep(c("phi_1 = 0.9 (Strong persistence)", 
                 "phi_1 = 0.5 (Moderate persistence)", 
                 "phi_1 = -0.7 (Oscillatory)",
                 "phi_1 = 0.1 (Weak persistence)"), each = n),
  phi = rep(c(0.9, 0.5, -0.7, 0.1), each = n),
  y = c(simulate_ar1(n, 0.9), 
        simulate_ar1(n, 0.5), 
        simulate_ar1(n, -0.7), 
        simulate_ar1(n, 0.1))
) |>
  as_tsibble(index = time, key = series)

# Plot AR(1) processes
p1 <- ar1_data |>
  ggplot(aes(x = time, y = y, color = series)) +
  geom_line(alpha = 0.8) +
  facet_wrap(~series, scales = "free_y", ncol = 2) +
  labs(title = "AR(1) Processes with Different phi_1 Values",
       x = "Time", y = "Value") +
  theme_minimal() +
  theme(legend.position = "none") +
  scale_color_viridis_d()

print(p1)
```

## AR(1) Autocorrelation Functions

```{r ar1_acf_pacf}
# Calculate theoretical ACF for AR(1)
calculate_ar1_acf <- function(phi, max_lag = 20) {
  lags <- 0:max_lag
  acf_values <- phi^lags
  return(data.frame(lag = lags, acf = acf_values))
}

# Create ACF plots for different phi_1 values
phi_values <- c(0.9, 0.5, -0.7, 0.1)
acf_plots <- list()

for (i in 1:length(phi_values)) {
  phi <- phi_values[i]
  theoretical_acf <- calculate_ar1_acf(phi)
  
  # Get sample data for this phi
  sample_data <- ar1_data |> 
    filter(phi == !!phi) |>
    as_tsibble(index = time)
  
  # Sample ACF
  sample_acf <- sample_data |> ACF(y, lag_max = 20)
  
  acf_plots[[i]] <- ggplot() +
    geom_col(data = sample_acf, aes(x = lag, y = acf), 
             fill = "steelblue", alpha = 0.7, width = 0.7) +
    geom_line(data = theoretical_acf, aes(x = lag, y = acf), 
              color = "red", linewidth = 1.2) +
    geom_point(data = theoretical_acf, aes(x = lag, y = acf), 
               color = "red", size = 2) +
    labs(title = paste("phi_1 =", phi), 
         x = "Lag", y = "ACF") +
    theme_minimal() +
    geom_hline(yintercept = 0, color = "black") +
    ylim(-1, 1)
}

# Arrange ACF plots
(acf_plots[[1]] + acf_plots[[2]]) / (acf_plots[[3]] + acf_plots[[4]]) +
  plot_annotation(title = "AR(1) Autocorrelation Functions: Sample (bars) vs Theoretical (red line)")
```

## AR(1) PACF and Stationarity

```{r ar1_pacf_stationarity}
# PACF for AR(1) processes
pacf_plots <- list()

for (i in 1:length(phi_values)) {
  phi <- phi_values[i]
  sample_data <- ar1_data |> 
    filter(phi == !!phi) |>
    as_tsibble(index = time)
  
  pacf_plots[[i]] <- sample_data |> 
    PACF(y, lag_max = 20) |>
    autoplot() +
    labs(title = paste("phi_1 =", phi)) +
    theme_minimal()
}

# Arrange PACF plots
(pacf_plots[[1]] + pacf_plots[[2]]) / (pacf_plots[[3]] + pacf_plots[[4]]) +
  plot_annotation(title = "AR(1) Partial Autocorrelation Functions")

# Stationarity visualization
phi_range <- seq(-0.99, 0.99, by = 0.01)
stationarity_data <- tibble(
  phi = phi_range,
  stationary = abs(phi) < 1,
  variance = ifelse(abs(phi) < 1, 1 / (1 - phi^2), NA)
)

p_stationarity <- ggplot(stationarity_data, aes(x = phi, y = variance)) +
  geom_line(color = "blue", linewidth = 1.2) +
  geom_vline(xintercept = c(-1, 1), color = "red", linetype = "dashed") +
  labs(title = "AR(1) Variance vs phi_1 Parameter",
       subtitle = "Variance explodes as |phi_1| approaches 1",
       x = "Ï† parameter", y = "Theoretical Variance") +
  theme_minimal() +
  ylim(0, 50)

print(p_stationarity)
```

---

# AR(2) Process Analysis

## Mathematical Foundation

An AR(2) process has the form:
$$Y_t =  \phi_0 + \phi_1 Y_{t-1} + \phi_2 Y_{t-2} + u_t$$

**Stationarity conditions**:
- $\phi_1 + \phi_2 < 1$
- $\phi_2 - \phi_1 < 1$  
- $|\phi_2| < 1$

**Characteristic equation**: $1 - \phi_1 z - \phi_2 z^2 = 0$

## AR(2) Process Simulation

```{r ar2_simulation}
# Function to simulate AR(2) process
simulate_ar2 <- function(n, phi1, phi2, c = 0, sigma = 1) {
  y <- numeric(n)
  u <- rnorm(n, 0, sigma)
  
  # Check stationarity
  if (!((phi1 + phi2 < 1) && (phi2 - phi1 < 1) && (abs(phi2) < 1))) {
    warning("Parameters may not satisfy stationarity conditions")
  }
  
  # Starting values (simplified)
  y[1] <- u[1]
  y[2] <- u[2]
  
  for (t in 3:n) {
    y[t] <- c + phi1 * y[t-1] + phi2 * y[t-2] + u[t]
  }
  
  return(y)
}

# Different AR(2) configurations
ar2_configs <- list(
  list(phi1 = 0.7, phi2 = 0.2, name = "phi_1=0.7, phi_2=0.2 (Real roots)"),
  list(phi1 = 0.5, phi2 = -0.3, name = "phi_1=0.5, phi_2=-0.3 (Real roots)"),
  list(phi1 = 1.0, phi2 = -0.6, name = "phi_1=1.0, phi_2=-0.6 (Complex roots)"),
  list(phi1 = 0.1, phi2 = 0.8, name = "phi_1=0.1, phi_2=0.8 (Complex roots)")
)

# Simulate AR(2) processes
ar2_data <- tibble()
for (i in 1:length(ar2_configs)) {
  config <- ar2_configs[[i]]
  y_sim <- simulate_ar2(n, config$phi1, config$phi2)
  
  temp_data <- tibble(
    time = 1:n,
    y = y_sim,
    series = config$name,
    phi1 = config$phi1,
    phi2 = config$phi2
  )
  ar2_data <- bind_rows(ar2_data, temp_data)
}

ar2_data <- ar2_data |> as_tsibble(index = time, key = series)

# Plot AR(2) processes
p2 <- ar2_data |>
  ggplot(aes(x = time, y = y, color = series)) +
  geom_line(alpha = 0.8) +
  facet_wrap(~series, scales = "free_y", ncol = 2) +
  labs(title = "AR(2) Processes with Different Parameter Combinations",
       x = "Time", y = "Value") +
  theme_minimal() +
  theme(legend.position = "none") +
  scale_color_viridis_d()

print(p2)
```

## AR(2) Autocorrelation Patterns

```{r ar2_acf_patterns}
# AR(2) ACF plots
ar2_acf_plots <- list()
series_names <- unique(ar2_data$series)

for (i in 1:length(series_names)) {
  series_name <- series_names[i]
  sample_data <- ar2_data |> 
    filter(series == !!series_name) |>
    as_tsibble(index = time)
  
  ar2_acf_plots[[i]] <- sample_data |> 
    ACF(y, lag_max = 20) |>
    autoplot() +
    labs(title = str_wrap(series_name, 25)) +
    theme_minimal() +
    theme(plot.title = element_text(size = 9))
}

# Arrange ACF plots
(ar2_acf_plots[[1]] + ar2_acf_plots[[2]]) / (ar2_acf_plots[[3]] + ar2_acf_plots[[4]]) +
  plot_annotation(title = "AR(2) Autocorrelation Functions")

# AR(2) PACF plots
ar2_pacf_plots <- list()

for (i in 1:length(series_names)) {
  series_name <- series_names[i]
  sample_data <- ar2_data |> 
    filter(series == !!series_name) |>
    as_tsibble(index = time)
  
  ar2_pacf_plots[[i]] <- sample_data |> 
    PACF(y, lag_max = 20) |>
    autoplot() +
    labs(title = str_wrap(series_name, 25)) +
    theme_minimal() +
    theme(plot.title = element_text(size = 9))
}

# Arrange PACF plots
(ar2_pacf_plots[[1]] + ar2_pacf_plots[[2]]) / (ar2_pacf_plots[[3]] + ar2_pacf_plots[[4]]) +
  plot_annotation(title = "AR(2) Partial Autocorrelation Functions")
```

## Estimation of AR(2)

We now estimate the Parameters of the AR(2) process using the conditional likelihood/regression appraoch from the slides:

```{r ar2_ols_estimation}
# Function to estimate AR(2) using OLS
estimate_ar2_ols <- function(y) {
  n <- length(y)
  p <- 2  # AR(2) model
  
  # Construct Y vector (observations from t=p+1 to T)
  Y <- y[(p+1):n]
  
  # Construct F matrix (design matrix)
  F_matrix <- matrix(0, nrow = n - p, ncol = p)
  for (i in 1:(n - p)) {
    F_matrix[i, ] <- c(y[p + i - 1], y[p + i - 2])
  }
  
  # OLS estimation: phi_hat = (F'F)^{-1} F'Y
  phi_hat <- solve(t(F_matrix) %*% F_matrix) %*% t(F_matrix) %*% Y
  
  # Calculate residuals
  residuals <- Y - F_matrix %*% phi_hat
  
  # Estimate sigma^2
  sigma2_hat <- var(residuals)
  
  # Optinal: Standard errors (using variance-covariance matrix)
  var_cov_matrix <- as.numeric(sigma2_hat) * solve(t(F_matrix) %*% F_matrix)
  se <- sqrt(diag(var_cov_matrix))
  
  return(list(
    phi_hat = as.vector(phi_hat),
    se = se,
    sigma2_hat = sigma2_hat,
    residuals = residuals
  ))
}

# Estimate parameters for each AR(2) configuration
estimation_results <- tibble()

for (i in 1:length(ar2_configs)) {
  config <- ar2_configs[[i]]
  
  # Get the simulated data for this configuration
  y_data <- ar2_data |> 
    filter(series == config$name) |>
    pull(y)
  
  # Estimate
  est <- estimate_ar2_ols(y_data)
  
  # Store results
  estimation_results <- bind_rows(estimation_results,
    tibble(
      series = config$name,
      true_phi1 = config$phi1,
      true_phi2 = config$phi2,
      estimated_phi1 = est$phi_hat[1],
      estimated_phi2 = est$phi_hat[2],
      se_phi1 = est$se[1],
      se_phi2 = est$se[2],
      sigma2_hat = est$sigma2_hat
    ))
}

# Display results
cat("\n=== AR(2) OLS Estimation Results ===\n\n")
print(estimation_results |> 
  select(series, true_phi1, estimated_phi1, se_phi1, true_phi2, estimated_phi2, se_phi2))
```


We see that the parameter estimates are very accurate! We also obtained an optional uncertainty estimation not discussed in the lecture:

```{r ar2_ols_estimation2}

##Plots:


# Create confidence interval plot
ci_data <- estimation_results |>
  mutate(
    ci_lower_phi1 = estimated_phi1 - 1.96 * se_phi1,
    ci_upper_phi1 = estimated_phi1 + 1.96 * se_phi1,
    ci_lower_phi2 = estimated_phi2 - 1.96 * se_phi2,
    ci_upper_phi2 = estimated_phi2 + 1.96 * se_phi2
  ) |>
  pivot_longer(cols = c(estimated_phi1, estimated_phi2),
               names_to = "parameter", values_to = "estimate") |>
  mutate(
    true_value = ifelse(parameter == "estimated_phi1", true_phi1, true_phi2),
    ci_lower = ifelse(parameter == "estimated_phi1", ci_lower_phi1, ci_lower_phi2),
    ci_upper = ifelse(parameter == "estimated_phi1", ci_upper_phi1, ci_upper_phi2),
    phi_label = ifelse(parameter == "estimated_phi1", "phi_1", "phi_2")
  )

p_ci <- ggplot(ci_data, aes(x = series, y = estimate)) +
  geom_point(size = 3, color = "coral") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0.2, color = "coral") +
  geom_point(aes(y = true_value), size = 3, color = "steelblue", shape = 17) +
  facet_wrap(~phi_label, scales = "free_y") +
  labs(title = "AR(2) Parameter Estimates with 95% Confidence Intervals",
       subtitle = "Circles = Estimates, Triangles = True Values",
       x = "", y = "Parameter Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8)) +
  coord_flip()

print(p_ci)
