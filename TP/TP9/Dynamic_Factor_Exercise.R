rm(list=ls())



library(sparseDFM)
library(doSNOW)
library(fpp3)
library(forecast)
library(patchwork)
library(dCovTS)
library(ggplot2)
library(reshape2)
library(MASS)
library(gridExtra)


data <- exports

#The sparseDFM package contains a data frame exports containing the 9 monthly target series
#of UK exports and the 434 monthly indicator series observed from January 2004 to October 2022.
# To try and produce accurate forecasts for the targets we use a large collection of 434 monthly
# indicator series including:
#   • Index of Production (IoP)-Movements in the volume of production for the UK production
# industries- 2 month lag- 89 series.
# • Consumer Price In ation (CPI)- The rate at which the prices of goods and services
# bought by households rise or fall- 1 month lag- 166 series.
# • Producer Price In ation (PPI)- Changes in the prices of goods bought and sold by UK
# manufacturers- 1 month lag- 153 series.
# • Exchange rates- Sterling exchange rates with 12 popular currencies- 1 month lag- 12
# series
# • Business condence Index (BCI)-Opinionsurveysondevelopments in production, orders
# and stocks of nished goods in the industry sector- 1 month lag- 1 series.
# • Consumer Condence Index (CCI)- Opinion surveys on future developments of house
# holds consumption and saving- 1 month lag- 1 series.
# • Google Trends (GT)- Popularity scores of 14 google search queries related to trade in
# goods- real-time- 14 series.


## We remove the last two rows with missing values:
data<-data[complete.cases(data),]


# Plot the 9 target series using ts.plot with a legend on the right
def.par <- par(no.readonly = TRUE) # initial graphic parameters
goods <- data[,1:9]
layout(matrix(c(1,2),nrow=1), width=c(4,3))
par(mar=c(5,4,4,0))
ts.plot(goods, gpars= list(col=10:1,lty=1:10))
par(mar=c(5,0,4,2))
plot(c(0,1),type="n", axes=F, xlab="", ylab="")
legend("center", legend = colnames(goods), col = 10:1, lty = 1:10, cex = 0.7)
par(def.par) # reset graphic parameters to initial


#To make the data stationary, we apply rst-di erence transformations to each series using:
new_data <- transformData(data, stationary_transform = rep(2, ncol(data)))

tuneFactors(new_data, type = 2, standardize = TRUE, plot = TRUE)


#According to the information criteria, the best number of factors to use is 7.
#However, the screeplot seems to suggest that after 4 factors, the addition of more factors does not
#add that much in terms of explaining the variance of the data. For this reason, we choose to use 4
#factors when modelling.
# We now t a regular DFM and a Sparse DFM to the data with 4 factors

## Regular DFM fit- takes around 18 seconds
fit.dfm <- sparseDFM(new_data, r = 4, alg = "EM")
## Sparse DFM fit- takes around 2 mins to tune
# set q = 9 as the first 9 variables (targets) should not be regularised
# L1 penalty grid set to logspace(0.4,1,15) after exploration
fit.sdfm <- sparseDFM(new_data, r = 4, q = 9, alg = "EM-sparse",
                      alphas = logspace(0.4,1,15))




# We now explore the estimated factors and loadings for the regular and sparse DFM ts. We
# are able to group the indicator series into colours depending on the source of the indicator and
# use the type = "loading.grouplineplot" setting in plot(). We set the trade in goods (TiG)
# target black, IoP blue, CPI red, PPI pink, exchange rate (Exch) green, BCI & CCI (Conf) navy
# and google trends (GT) brown. This will make it easier to visualise which indicators are loading
# onto speci c factors. Factor and loading plots can be generated by:

## Plot the estimated factors for the DFM
#plot(fit.dfm, type = "factor")

## Plot the estimated factors for the Sparse DFM
plot(fit.sdfm, type = "factor")
## Specify the name of the group each indicator belongs too
# this is a vector of length matching the number of columns of the data
groups = c(rep("TiG",9), rep("IoP",89), rep("CPI",166), rep("PPI",153),
           rep("Exch",12), rep("Conf",2), rep("GT",14))


## Specify the colours for each of the groups
# this is a vector of length matching the number of different groups
group_cols = c("black","blue","red","pink","green","navy","brown")
# ## Plot the DFM group lineplot in a 2 x 2 grid- uses the gridExtra package from CRAN.
# p1 = plot(fit.dfm, type = "loading.grouplineplot", loading.factor = 1,
#           group.names = groups, group.cols = group_cols)
# p2 = plot(fit.dfm, type = "loading.grouplineplot", loading.factor = 2,
#           group.names = groups, group.cols = group_cols)
# p3 = plot(fit.dfm, type = "loading.grouplineplot", loading.factor = 3,
#           group.names = groups, group.cols = group_cols)
# p4 = plot(fit.dfm, type = "loading.grouplineplot", loading.factor = 4,
#           group.names = groups, group.cols = group_cols)
# grid.arrange(p1, p2, p3, p4, nrow = 2)
## Do the same for the Sparse DFM fit
p5 = plot(fit.sdfm, type = "loading.grouplineplot", loading.factor = 1,
          group.names = groups, group.cols = group_cols)
p6 = plot(fit.sdfm, type = "loading.grouplineplot", loading.factor = 2,
          group.names = groups, group.cols = group_cols)
p7 = plot(fit.sdfm, type = "loading.grouplineplot", loading.factor = 3,
          group.names = groups, group.cols = group_cols)
p8 = plot(fit.sdfm, type = "loading.grouplineplot", loading.factor = 4,
          group.names = groups, group.cols = group_cols)
grid.arrange(p5, p6, p7, p8, nrow = 2)


# With sparse factor loadings, we are able to make a lot clearer conclusions on factor structure. We can clearly visualise which indicator
# series are the driving force between each factor. Factor 2 for example, with the obvious drop in
# early 2020 due to the COVID pandemic, is heavily loaded with indicators coming from the Index
# of Production, condence indices and google trends. Index of Production does not actually appear
# in any other factors and we can view this as a clear indicator of the COVID drop. It is interesting
# that google search words to do with trade in goods are present in factor 2 as well. With lots of
# economic volatility in recent years, using google trends search words may be a very useful indicator
# of economic activity. Factor 1 seems to be mainly loaded with PPI data, while factor 3 is heavily
# loaded with CPI data. Some in ation data and exchange rate indicators are present in factor 4,
# which seems to have shocks during the 2009 and 2020 recessions. Note that in all 4 factor loading
# plots the trade in goods target series are loaded as we speci ed q = 9 in the sparseDFM t to
# ensure these variables are not regularised.


# We now use this model to predict the last two months, using our simulated generate_prediction_intervals function:

generate_prediction_intervals <- function(fit, h, n_sim = 1000, level = 0.95) {
  
  # Extract model components
  # Y_t = Lambda * F_t + epsilon_t
  # F_t = A * F_{t-1} + u_t
  
  A <- fit$params$A                    # VAR coefficients
  Lambda <- fit$params$Lambda          # n_series x r
  Sigma_u <- fit$params$Sigma_u        # r x r
  Sigma_epsilon <- fit$params$Sigma_epsilon  # n_series x n_series (diagonal)
  
  n_series <- nrow(Lambda)
  r <- ncol(Lambda)
  p <- fit$p  # VAR lag order
  
  # Storage for simulations
  Y_sim <- array(NA, dim = c(h, n_series, n_sim))
  
  # Get E[F_{T+1} | F_T]
  FT1 <- predict(fit)$F_hat
  
  # Simulate from the DFM
  for(sim in 1:n_sim) {
    
    # Initialize factor simulations
    F_sim <- matrix(NA, h, r)
    
    # Draw F_{T+1} ~ N(E[F_{T+1}|F_T], Sigma_u)
    F_sim[1, ] <- FT1 + mvrnorm(1, mu = rep(0, r), Sigma = Sigma_u)
    
    # Draw Y_{T+1} | F_{T+1}
    Y_sim[1, , sim] <- Lambda %*% F_sim[1, ] + 
      mvrnorm(1, mu = rep(0, n_series), Sigma = diag(Sigma_epsilon))
    
    # Simulate forward h-1 more steps
    for(t in 2:h) {
      # Simulate F_t from VAR(1): F_t = A * F_{t-1} + u_t
      F_sim[t, ] <- A %*% F_sim[t-1, ] + 
        mvrnorm(1, mu = rep(0, r), Sigma = Sigma_u)
      
      # Simulate Y_t | F_t
      Y_sim[t, , sim] <- Lambda %*% F_sim[t, ] + 
        mvrnorm(1, mu = rep(0, n_series), Sigma = diag(Sigma_epsilon))
    }
  }
  
  # Calculate prediction intervals
  alpha <- 1 - level
  lower <- apply(Y_sim, c(1, 2), quantile, probs = alpha/2, na.rm = TRUE)
  upper <- apply(Y_sim, c(1, 2), quantile, probs = 1 - alpha/2, na.rm = TRUE)
  median_forecast <- apply(Y_sim, c(1, 2), median, na.rm = TRUE)
  
  return(list(
    median = median_forecast,
    lower = lower,
    upper = upper,
    simulations = Y_sim
  ))
}

set.seed(456)

# Generate 90% prediction intervals
pred_intervals <- generate_prediction_intervals(
  fit = fit.sdfm,
  h = 10,
  n_sim = 200,
  level = 0.90
)


# Visualization of predictions for the 9 target series
# Extract the target series (first 9 columns)
target_names <- colnames(data)[1:9]

### Not sure if this is necessary
